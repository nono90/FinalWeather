#define MCG_WINRT_SUPPORTED
using Mcg.System;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.WindowsRuntime;
using global::Windows.Foundation;
using global::Windows.Foundation.Collections;


// -----------------------------------------------------------------------------------------------------------
// 
// WARNING: THIS SOURCE FILE IS FOR 32-BIT BUILDS ONLY!
// 
// MCG GENERATED CODE
// 
// This C# source file is generated by MCG and is added into the application at compile time to support interop features.
// 
// It has three primary components:
// 
// 1. Public type definitions with interop implementation used by this application including WinRT & COM data structures and P/Invokes.
// 
// 2. The '__Interop' class containing marshaling code that acts as a bridge from managed code to native code.
// 
// 3. The 'McgNative' class containing marshaling code and native type definitions that call into native code and are called by native code.
// 
// -----------------------------------------------------------------------------------------------------------
// 
// warning CS0067: The event 'event' is never used
#pragma warning disable 67
// warning CS0169: The field 'field' is never used
#pragma warning disable 169
// warning CS0649: Field 'field' is never assigned to, and will always have its default value 0
#pragma warning disable 414
// warning CS0414: The private field 'field' is assigned but its value is never used
#pragma warning disable 649
// warning CS1591: Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// warning CS0108 'member1' hides inherited member 'member2'. Use the new keyword if hiding was intended.
#pragma warning disable 108
// warning CS0114 'member1' hides inherited member 'member2'.  To make the current method override that implementation, add the override keyword. Otherwise add the new keyword.
#pragma warning disable 114
// warning CS0659 'type' overrides Object.Equals but does not override GetHashCode.
#pragma warning disable 659
// warning CS0465 Introducing a 'Finalize' method can interfere with destructor invocation. Did you intend to declare a destructor?
#pragma warning disable 465
// warning CS0028 'function declaration' has the wrong signature to be an entry point
#pragma warning disable 28
// warning CS0162 Unreachable code Detected
#pragma warning disable 162
// warning CS0628 new protected member declared in sealed class
#pragma warning disable 628

namespace __Interop
{
	/// <summary>
	/// P/Invoke class for module '[MRT]'
	/// </summary>
	public unsafe static partial class _MRT_
	{
		// Signature, RhpGetFuncEvalParameterBufferSize, [fwd] [return] [EETypeRva:0x00041980] uint__unsigned int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "RhpGetFuncEvalParameterBufferSize")]
		public static uint RhpGetFuncEvalParameterBufferSize()
		{
			// Setup
			uint unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop._MRT__PInvokes.RhpGetFuncEvalParameterBufferSize();
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, RhpGetFuncEvalMode, [fwd] [return] [EETypeRva:0x00041980] uint__unsigned int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "RhpGetFuncEvalMode")]
		public static uint RhpGetFuncEvalMode()
		{
			// Setup
			uint unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop._MRT__PInvokes.RhpGetFuncEvalMode();
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, RhpRecordDebuggeeInitiatedHandle, [fwd] [return] [EETypeRva:0x00041980] uint__unsigned int, [fwd] [in] [EETypeRva:0x00041980] void___ptrvoid *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "RhpRecordDebuggeeInitiatedHandle")]
		public static uint RhpRecordDebuggeeInitiatedHandle(void* objectHandle)
		{
			// Setup
			uint unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop._MRT__PInvokes.RhpRecordDebuggeeInitiatedHandle(((void*)objectHandle));
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, RhpVerifyDebuggerCleanup, [fwd] [return] [EETypeRva:0x00041F3C] void__void, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "RhpVerifyDebuggerCleanup")]
		public static void RhpVerifyDebuggerCleanup()
		{
			// Marshalling
			// Call to native method
			global::__Interop._MRT__PInvokes.RhpVerifyDebuggerCleanup();
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
		}

		// Signature, RhpGetCurrentThread, [fwd] [return] [EETypeRva:0x00041980] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "RhpGetCurrentThread")]
		public static global::System.IntPtr RhpGetCurrentThread()
		{
			// Setup
			global::System.IntPtr unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop._MRT__PInvokes.RhpGetCurrentThread();
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, RhWaitForPendingFinalizers, [fwd] [return] [EETypeRva:0x00041F3C] void__void, [fwd] [in] [EETypeRva:0x00041980] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "RhWaitForPendingFinalizers")]
		public static void RhWaitForPendingFinalizers(int allowReentrantWait)
		{
			// Marshalling
			// Call to native method
			global::__Interop._MRT__PInvokes.RhWaitForPendingFinalizers(allowReentrantWait);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
		}

		// Signature, _RhYield, [fwd] [return] [EETypeRva:0x00041980] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "_RhYield")]
		public static int _RhYield()
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop._MRT__PInvokes._RhYield();
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, RhFlushProcessWriteBuffers, [fwd] [return] [EETypeRva:0x00041F3C] void__void, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "RhFlushProcessWriteBuffers")]
		public static void RhFlushProcessWriteBuffers()
		{
			// Marshalling
			// Call to native method
			global::__Interop._MRT__PInvokes.RhFlushProcessWriteBuffers();
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
		}

		// Signature, RhCompatibleReentrantWaitAny, [fwd] [return] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr___ptr__w64 int *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "RhCompatibleReentrantWaitAny")]
		public static int RhCompatibleReentrantWaitAny(
					int alertable, 
					int timeout, 
					int count, 
					global::System.IntPtr* handles)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop._MRT__PInvokes.RhCompatibleReentrantWaitAny(
								alertable, 
								timeout, 
								count, 
								((global::System.IntPtr*)handles)
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, RhCallDescrWorkerNative, [fwd] [return] [EETypeRva:0x00041F3C] void__void, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "RhCallDescrWorkerNative")]
		public static void RhCallDescrWorkerNative(global::System.IntPtr callDescr)
		{
			// Marshalling
			// Call to native method
			global::__Interop._MRT__PInvokes.RhCallDescrWorkerNative(callDescr);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
		}

		// Signature, _ecvt_s, [fwd] [return] [EETypeRva:0x00041F3C] void__void, [fwd] [in] [EETypeRva:0x00041980] byte___ptrunsigned char *, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] double__double, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] int___ptrint *, [fwd] [in] [EETypeRva:0x00041980] int___ptrint *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "_ecvt_s")]
		public static void _ecvt_s(
					byte* buffer, 
					int sizeInBytes, 
					double value, 
					int count, 
					int* dec, 
					int* sign)
		{
			// Marshalling
			// Call to native method
			global::__Interop._MRT__PInvokes._ecvt_s(
								((byte*)buffer), 
								sizeInBytes, 
								value, 
								count, 
								((int*)dec), 
								((int*)sign)
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
		}

		// Signature, memmove, [fwd] [return] [EETypeRva:0x00041F3C] void__void, [fwd] [in] [EETypeRva:0x00041980] byte___ptrunsigned char *, [fwd] [in] [EETypeRva:0x00041980] byte___ptrunsigned char *, [fwd] [in] [EETypeRva:0x00041980] uint__unsigned int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "memmove")]
		public static void memmove(
					byte* dmem, 
					byte* smem, 
					uint size)
		{
			// Marshalling
			// Call to native method
			global::__Interop._MRT__PInvokes.memmove(
								((byte*)dmem), 
								((byte*)smem), 
								size
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
		}

		// Signature, memset, [fwd] [return] [EETypeRva:0x00041F3C] void__void, [fwd] [in] [EETypeRva:0x00041980] byte___ptrunsigned char *, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] uint__unsigned int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "memset")]
		public static void memset(
					byte* mem, 
					int value, 
					uint size)
		{
			// Marshalling
			// Call to native method
			global::__Interop._MRT__PInvokes.memset(
								((byte*)mem), 
								value, 
								size
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
		}
	}

	/// <summary>
	/// P/Invoke class for module '*'
	/// </summary>
	public unsafe static partial class _
	{
		// Signature, CallingConventionConverter_GetStubs, [fwd] [return] [EETypeRva:0x00041F3C] void__void, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x00041980] System_IntPtr____w64 int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x00041980] System_IntPtr____w64 int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x00041980] System_IntPtr____w64 int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x00041980] System_IntPtr____w64 int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x00041980] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.TypeLoader, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Internal.Runtime.TypeLoader.CallConverterThunk", "CallingConventionConverter_GetStubs")]
		public static void CallingConventionConverter_GetStubs(
					out global::System.IntPtr returnVoidStub, 
					out global::System.IntPtr returnIntegerStub, 
					out global::System.IntPtr commonStub, 
					out global::System.IntPtr returnFloatingPointReturn4Thunk, 
					out global::System.IntPtr returnFloatingPointReturn8Thunk)
		{
			// Marshalling
			fixed (global::System.IntPtr* pinned_returnVoidStub = &(returnVoidStub))
				fixed (global::System.IntPtr* pinned_returnIntegerStub = &(returnIntegerStub))
					fixed (global::System.IntPtr* pinned_commonStub = &(commonStub))
						fixed (global::System.IntPtr* pinned_returnFloatingPointReturn4Thunk = &(returnFloatingPointReturn4Thunk))
							fixed (global::System.IntPtr* pinned_returnFloatingPointReturn8Thunk = &(returnFloatingPointReturn8Thunk))
							{
								// Call to native method
								global::__Interop.__PInvokes.CallingConventionConverter_GetStubs(
													pinned_returnVoidStub, 
													pinned_returnIntegerStub, 
													pinned_commonStub, 
													pinned_returnFloatingPointReturn4Thunk, 
													pinned_returnFloatingPointReturn8Thunk
												);
								global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
							}
			// Return
		}
	}

	/// <summary>
	/// P/Invoke class for module 'api-ms-win-core-winrt-string-l1-1-0.dll'
	/// </summary>
	public unsafe static partial class api_ms_win_core_winrt_string_l1_1_0_dll
	{
		// Signature, WindowsCreateStringReference, [fwd] [return] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] char___ptrwchar_t *, [fwd] [in] [EETypeRva:0x00041980] uint__unsigned int, [fwd] [in] [EETypeRva:0x00041980] System_Runtime_InteropServices_HSTRING_HEADER__System_Private_Interop___ptrSystem_Runtime_InteropServices__HSTRING_HEADER__System_Private_Interop *, [fwd] [in] [EETypeRva:0x00041980] void___ptrvoid *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.WinRTInterop.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", "mincore", "WindowsCreateStringReference")]
		public static int WindowsCreateStringReference(
					char* sourceString, 
					uint length, 
					global::System_Runtime_InteropServices.HSTRING_HEADER__System_Private_Interop* phstringHeader, 
					void* hstring)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop.api_ms_win_core_winrt_string_l1_1_0_dll_PInvokes.WindowsCreateStringReference(
								((ushort*)sourceString), 
								length, 
								((global::System_Runtime_InteropServices.HSTRING_HEADER__System_Private_Interop*)phstringHeader), 
								((void*)hstring)
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}
	}

	/// <summary>
	/// P/Invoke class for module 'api-ms-win-core-errorhandling-l1-1-0.dll'
	/// </summary>
	public unsafe static partial class api_ms_win_core_errorhandling_l1_1_0_dll
	{
		// Signature, GetLastError, [fwd] [return] [EETypeRva:0x00041980] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+mincore", "GetLastError")]
		public static int GetLastError()
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop.api_ms_win_core_errorhandling_l1_1_0_dll_PInvokes.GetLastError();
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, SetLastError, [fwd] [return] [EETypeRva:0x00041F3C] void__void, [fwd] [in] [EETypeRva:0x00041980] uint__unsigned int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+mincore", "SetLastError")]
		public static void SetLastError(uint dwErrCode)
		{
			// Marshalling
			// Call to native method
			global::__Interop.api_ms_win_core_errorhandling_l1_1_0_dll_PInvokes.SetLastError(dwErrCode);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
		}
	}

	/// <summary>
	/// P/Invoke class for module 'api-ms-win-core-winrt-l1-1-0.dll'
	/// </summary>
	public unsafe static partial class api_ms_win_core_winrt_l1_1_0_dll
	{
		// Signature, RoInitialize, [fwd] [return] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] uint__unsigned int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.WinRTInterop.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", "mincore+mincore_PInvokes", "RoInitialize")]
		public static int RoInitialize(uint initType)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop.api_ms_win_core_winrt_l1_1_0_dll_PInvokes.RoInitialize(initType);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}
	}

	/// <summary>
	/// P/Invoke class for module 'api-ms-win-core-localization-l1-2-0.dll'
	/// </summary>
	public unsafe static partial class api_ms_win_core_localization_l1_2_0_dll
	{
		// Signature, IsValidLocaleName, [fwd] [return] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] char___ptrwchar_t *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.WinRTInterop.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", "mincore+mincore_PInvokes", "IsValidLocaleName")]
		public static int IsValidLocaleName(char* lpLocaleName)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop.api_ms_win_core_localization_l1_2_0_dll_PInvokes.IsValidLocaleName(((ushort*)lpLocaleName));
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, ResolveLocaleName, [fwd] [return] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] char___ptrwchar_t *, [fwd] [in] [EETypeRva:0x00041980] char___ptrwchar_t *, [fwd] [in] [EETypeRva:0x00041980] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.WinRTInterop.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", "mincore+mincore_PInvokes", "ResolveLocaleName")]
		public static int ResolveLocaleName(
					char* lpNameToResolve, 
					char* lpLocaleName, 
					int cchLocaleName)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop.api_ms_win_core_localization_l1_2_0_dll_PInvokes.ResolveLocaleName(
								((ushort*)lpNameToResolve), 
								((ushort*)lpLocaleName), 
								cchLocaleName
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}
	}

	/// <summary>
	/// P/Invoke class for module 'crypt32.dll'
	/// </summary>
	public unsafe static partial class crypt32_dll
	{
		// Signature, CertDuplicateCertificateContext, [fwd] [return] [EETypeRva:0x00043474] Internal_Cryptography_Pal_Native_SafeCertContextHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertDuplicateCertificateContext")]
		public static global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates CertDuplicateCertificateContext(global::System.IntPtr pCertContext)
		{
			// Setup
			global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates __value;
			global::System.IntPtr unsafe___value;
			// Marshalling
			__value = new global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates();
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.crypt32_dll_PInvokes.CertDuplicateCertificateContext(pCertContext);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								__value, 
								unsafe___value
							);
			// Return
			return __value;
		}

		// Signature, CertGetCertificateContextProperty, [fwd] [return] [EETypeRva:0x00040818] bool__System.Boolean, [fwd] [in] [EETypeRva:0x00043474] Internal_Cryptography_Pal_Native_SafeCertContextHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [EETypeRva:0x00042D30] Internal_Cryptography_Pal_Native_CertContextPropId__System_Security_Cryptography_X509Certificates__CertContextPropId__System_Security_Cryptography_X509Certificates, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x0004311C] Internal_Cryptography_Pal_Native_CRYPTOAPI_BLOB__System_Security_Cryptography_X509Certificates__Internal_Cryptography_Pal_Native__CRYPTOAPI_BLOB__System_Security_Cryptography_X509Certificates, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x00041980] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertGetCertificateContextProperty")]
		public static bool CertGetCertificateContextProperty(
					global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates pCertContext, 
					global::Internal_Cryptography_Pal_Native.CertContextPropId__System_Security_Cryptography_X509Certificates dwPropId, 
					out global::Internal_Cryptography_Pal_Native.CRYPTOAPI_BLOB__System_Security_Cryptography_X509Certificates pvData, 
					ref int pcbData)
		{
			// Setup
			bool addRefed = false;
			int unsafe___value;
			// Marshalling
			pCertContext.DangerousAddRef(ref addRefed);
			fixed (global::Internal_Cryptography_Pal_Native.CRYPTOAPI_BLOB__System_Security_Cryptography_X509Certificates* pinned_pvData = &(pvData))
				fixed (int* pinned_pcbData = &(pcbData))
				{
					global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
					// Call to native method
					unsafe___value = global::__Interop.crypt32_dll_PInvokes.CertGetCertificateContextProperty(
										pCertContext.DangerousGetHandle(), 
										dwPropId, 
										pinned_pvData, 
										pinned_pcbData
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				}
			if (addRefed)
				pCertContext.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CryptQueryObject, [fwd] [return] [EETypeRva:0x00040818] bool__System.Boolean, [fwd] [in] [EETypeRva:0x00042D30] Internal_Cryptography_Pal_Native_CertQueryObjectType__System_Security_Cryptography_X509Certificates__CertQueryObjectType__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00041980] void___ptrvoid *, [fwd] [in] [EETypeRva:0x00042D30] Internal_Cryptography_Pal_Native_ExpectedContentTypeFlags__System_Security_Cryptography_X509Certificates__ExpectedContentTypeFlags__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00042D30] Internal_Cryptography_Pal_Native_ExpectedFormatTypeFlags__System_Security_Cryptography_X509Certificates__ExpectedFormatTypeFlags__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x00042D30] Internal_Cryptography_Pal_Native_CertEncodingType__System_Security_Cryptography_X509Certificates__CertEncodingType__System_Security_Cryptography_X509Certificates, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x00042D30] Internal_Cryptography_Pal_Native_ContentType__System_Security_Cryptography_X509Certificates__ContentType__System_Security_Cryptography_X509Certificates, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x00042D30] Internal_Cryptography_Pal_Native_FormatType__System_Security_Cryptography_X509Certificates__FormatType__System_Security_Cryptography_X509Certificates, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x00043474] Internal_Cryptography_Pal_Native_SafeCertStoreHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x00043474] Internal_Cryptography_Pal_Native_SafeCryptMsgHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x00043474] Internal_Cryptography_Pal_Native_SafeCertContextHandle__System_Security_Cryptography_X509Certificates____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CryptQueryObject")]
		public static bool CryptQueryObject(
					global::Internal_Cryptography_Pal_Native.CertQueryObjectType__System_Security_Cryptography_X509Certificates dwObjectType, 
					void* pvObject, 
					global::Internal_Cryptography_Pal_Native.ExpectedContentTypeFlags__System_Security_Cryptography_X509Certificates dwExpectedContentTypeFlags, 
					global::Internal_Cryptography_Pal_Native.ExpectedFormatTypeFlags__System_Security_Cryptography_X509Certificates dwExpectedFormatTypeFlags, 
					int dwFlags, 
					out global::Internal_Cryptography_Pal_Native.CertEncodingType__System_Security_Cryptography_X509Certificates pdwMsgAndCertEncodingType, 
					out global::Internal_Cryptography_Pal_Native.ContentType__System_Security_Cryptography_X509Certificates pdwContentType, 
					out global::Internal_Cryptography_Pal_Native.FormatType__System_Security_Cryptography_X509Certificates pdwFormatType, 
					out global::Internal.Cryptography.Pal.Native.SafeCertStoreHandle__System_Security_Cryptography_X509Certificates phCertStore, 
					out global::Internal.Cryptography.Pal.Native.SafeCryptMsgHandle__System_Security_Cryptography_X509Certificates phMsg, 
					out global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates ppvContext)
		{
			// Setup
			global::System.IntPtr unsafe_phCertStore;
			global::System.IntPtr unsafe_phMsg;
			global::System.IntPtr unsafe_ppvContext;
			int unsafe___value;
			// Marshalling
			fixed (global::Internal_Cryptography_Pal_Native.CertEncodingType__System_Security_Cryptography_X509Certificates* pinned_pdwMsgAndCertEncodingType = &(pdwMsgAndCertEncodingType))
				fixed (global::Internal_Cryptography_Pal_Native.ContentType__System_Security_Cryptography_X509Certificates* pinned_pdwContentType = &(pdwContentType))
					fixed (global::Internal_Cryptography_Pal_Native.FormatType__System_Security_Cryptography_X509Certificates* pinned_pdwFormatType = &(pdwFormatType))
					{
						phCertStore = new global::Internal.Cryptography.Pal.Native.SafeCertStoreHandle__System_Security_Cryptography_X509Certificates();
						unsafe_phCertStore = phCertStore.DangerousGetHandle();
						phMsg = new global::Internal.Cryptography.Pal.Native.SafeCryptMsgHandle__System_Security_Cryptography_X509Certificates();
						unsafe_phMsg = phMsg.DangerousGetHandle();
						ppvContext = new global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates();
						unsafe_ppvContext = ppvContext.DangerousGetHandle();
						global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
						// Call to native method
						unsafe___value = global::__Interop.crypt32_dll_PInvokes.CryptQueryObject(
											dwObjectType, 
											((void*)pvObject), 
											dwExpectedContentTypeFlags, 
											dwExpectedFormatTypeFlags, 
											dwFlags, 
											pinned_pdwMsgAndCertEncodingType, 
											pinned_pdwContentType, 
											pinned_pdwFormatType, 
											&(unsafe_phCertStore), 
											&(unsafe_phMsg), 
											&(unsafe_ppvContext)
										);
						global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
						global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
						global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
											ppvContext, 
											unsafe_ppvContext
										);
						global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
											phMsg, 
											unsafe_phMsg
										);
						global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
											phCertStore, 
											unsafe_phCertStore
										);
					}
			// Return
			return unsafe___value != 0;
		}

		// Signature, CertDuplicateCertificateContextWithKeyContainerDeletion, [fwd] [return] [EETypeRva:0x00043474] Internal_Cryptography_Pal_Native_SafeCertContextHandleWithKeyContainerDeletion__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertDuplicateCertificateContextWithKeyContainerDeletion")]
		public static global::Internal.Cryptography.Pal.Native.SafeCertContextHandleWithKeyContainerDeletion__System_Security_Cryptography_X509Certificates CertDuplicateCertificateContextWithKeyContainerDeletion(global::System.IntPtr pCertContext)
		{
			// Setup
			global::Internal.Cryptography.Pal.Native.SafeCertContextHandleWithKeyContainerDeletion__System_Security_Cryptography_X509Certificates __value;
			global::System.IntPtr unsafe___value;
			// Marshalling
			__value = new global::Internal.Cryptography.Pal.Native.SafeCertContextHandleWithKeyContainerDeletion__System_Security_Cryptography_X509Certificates();
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.crypt32_dll_PInvokes.CertDuplicateCertificateContextWithKeyContainerDeletion(pCertContext);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								__value, 
								unsafe___value
							);
			// Return
			return __value;
		}

		// Signature, CertFreeCertificateContext, [fwd] [return] [EETypeRva:0x00040818] bool__System.Boolean, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertFreeCertificateContext")]
		public static bool CertFreeCertificateContext(global::System.IntPtr pCertContext)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.crypt32_dll_PInvokes.CertFreeCertificateContext(pCertContext);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CryptMsgGetParam, [fwd] [return] [EETypeRva:0x00040818] bool__System.Boolean, [fwd] [in] [EETypeRva:0x00043474] Internal_Cryptography_Pal_Native_SafeCryptMsgHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [EETypeRva:0x00042D30] Internal_Cryptography_Pal_Native_CryptMessageParameterType__System_Security_Cryptography_X509Certificates__CryptMessageParameterType__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x00041980] int__int, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x00041980] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CryptMsgGetParam")]
		public static bool CryptMsgGetParam(
					global::Internal.Cryptography.Pal.Native.SafeCryptMsgHandle__System_Security_Cryptography_X509Certificates hCryptMsg, 
					global::Internal_Cryptography_Pal_Native.CryptMessageParameterType__System_Security_Cryptography_X509Certificates dwParamType, 
					int dwIndex, 
					out int pvData, 
					ref int pcbData)
		{
			// Setup
			bool addRefed = false;
			int unsafe___value;
			// Marshalling
			hCryptMsg.DangerousAddRef(ref addRefed);
			fixed (int* pinned_pvData = &(pvData))
				fixed (int* pinned_pcbData = &(pcbData))
				{
					global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
					// Call to native method
					unsafe___value = global::__Interop.crypt32_dll_PInvokes.CryptMsgGetParam(
										hCryptMsg.DangerousGetHandle(), 
										dwParamType, 
										dwIndex, 
										pinned_pvData, 
										pinned_pcbData
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				}
			if (addRefed)
				hCryptMsg.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CryptMsgGetParam__0, [fwd] [return] [EETypeRva:0x00040818] bool__System.Boolean, [fwd] [in] [EETypeRva:0x00043474] Internal_Cryptography_Pal_Native_SafeCryptMsgHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [EETypeRva:0x00042D30] Internal_Cryptography_Pal_Native_CryptMessageParameterType__System_Security_Cryptography_X509Certificates__CryptMessageParameterType__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] byte___ptrunsigned char *, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x00041980] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CryptMsgGetParam")]
		public static bool CryptMsgGetParam__0(
					global::Internal.Cryptography.Pal.Native.SafeCryptMsgHandle__System_Security_Cryptography_X509Certificates hCryptMsg, 
					global::Internal_Cryptography_Pal_Native.CryptMessageParameterType__System_Security_Cryptography_X509Certificates dwParamType, 
					int dwIndex, 
					byte* pvData, 
					ref int pcbData)
		{
			// Setup
			bool addRefed = false;
			int unsafe___value;
			// Marshalling
			hCryptMsg.DangerousAddRef(ref addRefed);
			fixed (int* pinned_pcbData = &(pcbData))
			{
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.crypt32_dll_PInvokes.CryptMsgGetParam__0(
									hCryptMsg.DangerousGetHandle(), 
									dwParamType, 
									dwIndex, 
									((byte*)pvData), 
									pinned_pcbData
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			if (addRefed)
				hCryptMsg.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, PFXImportCertStore, [fwd] [return] [EETypeRva:0x00043474] Internal_Cryptography_Pal_Native_SafeCertStoreHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [managedbyref] [nativebyref] [EETypeRva:0x0004311C] Internal_Cryptography_Pal_Native_CRYPTOAPI_BLOB__System_Security_Cryptography_X509Certificates__Internal_Cryptography_Pal_Native__CRYPTOAPI_BLOB__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00043474] Microsoft_Win32_SafeHandles_SafePasswordHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [EETypeRva:0x00042D30] Internal_Cryptography_Pal_Native_PfxCertStoreFlags__System_Security_Cryptography_X509Certificates__PfxCertStoreFlags__System_Security_Cryptography_X509Certificates, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "PFXImportCertStore")]
		public static global::Internal.Cryptography.Pal.Native.SafeCertStoreHandle__System_Security_Cryptography_X509Certificates PFXImportCertStore(
					ref global::Internal_Cryptography_Pal_Native.CRYPTOAPI_BLOB__System_Security_Cryptography_X509Certificates pPFX, 
					global::Microsoft.Win32.SafeHandles.SafePasswordHandle__System_Security_Cryptography_X509Certificates password, 
					global::Internal_Cryptography_Pal_Native.PfxCertStoreFlags__System_Security_Cryptography_X509Certificates dwFlags)
		{
			// Setup
			bool addRefed = false;
			global::Internal.Cryptography.Pal.Native.SafeCertStoreHandle__System_Security_Cryptography_X509Certificates __value;
			global::System.IntPtr unsafe___value;
			// Marshalling
			fixed (global::Internal_Cryptography_Pal_Native.CRYPTOAPI_BLOB__System_Security_Cryptography_X509Certificates* pinned_pPFX = &(pPFX))
			{
				password.DangerousAddRef(ref addRefed);
				__value = new global::Internal.Cryptography.Pal.Native.SafeCertStoreHandle__System_Security_Cryptography_X509Certificates();
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.crypt32_dll_PInvokes.PFXImportCertStore(
									pinned_pPFX, 
									password.DangerousGetHandle(), 
									dwFlags
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
									__value, 
									unsafe___value
								);
				if (addRefed)
					password.DangerousRelease();
			}
			// Return
			return __value;
		}

		// Signature, CryptFindOIDInfo, [fwd] [return] [EETypeRva:0x00041980] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00042D30] __Interop_Crypt32_CryptOidInfoKeyType__System_Security_Cryptography_Encoding__Interop_Crypt32_CryptOidInfoKeyType__System_Security_Cryptography_Encoding, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00042D30] System_Security_Cryptography_OidGroup__System_Security_Cryptography_Encoding__OidGroup__System_Security_Cryptography_Encoding, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Encoding, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Crypt32", "CryptFindOIDInfo")]
		public static global::System.IntPtr CryptFindOIDInfo(
					global::_.Interop_Crypt32_CryptOidInfoKeyType__System_Security_Cryptography_Encoding dwKeyType, 
					global::System.IntPtr pvKey, 
					global::System_Security_Cryptography.OidGroup__System_Security_Cryptography_Encoding group)
		{
			// Setup
			global::System.IntPtr unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop.crypt32_dll_PInvokes.CryptFindOIDInfo(
								dwKeyType, 
								pvKey, 
								group
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, CertGetCertificateContextProperty__0, [fwd] [return] [EETypeRva:0x00040818] bool__System.Boolean, [fwd] [in] [EETypeRva:0x00043474] Internal_Cryptography_Pal_Native_SafeCertContextHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [EETypeRva:0x00042D30] Internal_Cryptography_Pal_Native_CertContextPropId__System_Security_Cryptography_X509Certificates__CertContextPropId__System_Security_Cryptography_X509Certificates, [fwd] [out] [EETypeRva:0x00042A10] rg_byte__unsigned char *, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x00041980] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertGetCertificateContextProperty")]
		public static bool CertGetCertificateContextProperty__0(
					global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates pCertContext, 
					global::Internal_Cryptography_Pal_Native.CertContextPropId__System_Security_Cryptography_X509Certificates dwPropId, 
					byte[] pvData, 
					ref int pcbData)
		{
			// Setup
			bool addRefed = false;
			byte* unsafe_pvData;
			int unsafe___value;
			// Marshalling
			pCertContext.DangerousAddRef(ref addRefed);
			fixed (byte* pinned_pvData = ((pvData != null 
						&& pvData.Length == 0) ? new byte[1] : pvData))
			{
				unsafe_pvData = (byte*)pinned_pvData;
				fixed (int* pinned_pcbData = &(pcbData))
				{
					global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
					// Call to native method
					unsafe___value = global::__Interop.crypt32_dll_PInvokes.CertGetCertificateContextProperty__0(
										pCertContext.DangerousGetHandle(), 
										dwPropId, 
										unsafe_pvData, 
										pinned_pcbData
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				}
			}
			if (addRefed)
				pCertContext.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CertCloseStore, [fwd] [return] [EETypeRva:0x00040818] bool__System.Boolean, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00041980] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertCloseStore")]
		public static bool CertCloseStore(
					global::System.IntPtr hCertStore, 
					int dwFlags)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.crypt32_dll_PInvokes.CertCloseStore(
								hCertStore, 
								dwFlags
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CryptMsgClose, [fwd] [return] [EETypeRva:0x00040818] bool__System.Boolean, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CryptMsgClose")]
		public static bool CryptMsgClose(global::System.IntPtr hCryptMsg)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.crypt32_dll_PInvokes.CryptMsgClose(hCryptMsg);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CertFindCertificateInStore, [fwd] [return] [EETypeRva:0x00043474] Internal_Cryptography_Pal_Native_SafeCertContextHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [EETypeRva:0x00043474] Internal_Cryptography_Pal_Native_SafeCertStoreHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [EETypeRva:0x00042D30] Internal_Cryptography_Pal_Native_CertEncodingType__System_Security_Cryptography_X509Certificates__CertEncodingType__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00042D30] Internal_Cryptography_Pal_Native_CertFindFlags__System_Security_Cryptography_X509Certificates__CertFindFlags__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00042D30] Internal_Cryptography_Pal_Native_CertFindType__System_Security_Cryptography_X509Certificates__CertFindType__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00041980] void___ptrvoid *, [fwd] [in] [EETypeRva:0x00041980] Internal_Cryptography_Pal_Native_CERT_CONTEXT__System_Security_Cryptography_X509Certificates___ptrInternal_Cryptography_Pal_Native__CERT_CONTEXT__System_Security_Cryptography_X509Certificates *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertFindCertificateInStore")]
		public static global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates CertFindCertificateInStore(
					global::Internal.Cryptography.Pal.Native.SafeCertStoreHandle__System_Security_Cryptography_X509Certificates hCertStore, 
					global::Internal_Cryptography_Pal_Native.CertEncodingType__System_Security_Cryptography_X509Certificates dwCertEncodingType, 
					global::Internal_Cryptography_Pal_Native.CertFindFlags__System_Security_Cryptography_X509Certificates dwFindFlags, 
					global::Internal_Cryptography_Pal_Native.CertFindType__System_Security_Cryptography_X509Certificates dwFindType, 
					void* pvFindPara, 
					global::Internal_Cryptography_Pal_Native.CERT_CONTEXT__System_Security_Cryptography_X509Certificates* pPrevCertContext)
		{
			// Setup
			bool addRefed = false;
			global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates __value;
			global::System.IntPtr unsafe___value;
			// Marshalling
			hCertStore.DangerousAddRef(ref addRefed);
			__value = new global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates();
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.crypt32_dll_PInvokes.CertFindCertificateInStore(
								hCertStore.DangerousGetHandle(), 
								dwCertEncodingType, 
								dwFindFlags, 
								dwFindType, 
								((void*)pvFindPara), 
								((global::Internal_Cryptography_Pal_Native.CERT_CONTEXT__System_Security_Cryptography_X509Certificates*)pPrevCertContext)
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								__value, 
								unsafe___value
							);
			if (addRefed)
				hCertStore.DangerousRelease();
			// Return
			return __value;
		}

		// Signature, CertEnumCertificatesInStore, [fwd] [return] [EETypeRva:0x00043474] Internal_Cryptography_Pal_Native_SafeCertContextHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [EETypeRva:0x00043474] Internal_Cryptography_Pal_Native_SafeCertStoreHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [EETypeRva:0x00041980] Internal_Cryptography_Pal_Native_CERT_CONTEXT__System_Security_Cryptography_X509Certificates___ptrInternal_Cryptography_Pal_Native__CERT_CONTEXT__System_Security_Cryptography_X509Certificates *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertEnumCertificatesInStore")]
		public static global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates CertEnumCertificatesInStore(
					global::Internal.Cryptography.Pal.Native.SafeCertStoreHandle__System_Security_Cryptography_X509Certificates hCertStore, 
					global::Internal_Cryptography_Pal_Native.CERT_CONTEXT__System_Security_Cryptography_X509Certificates* pPrevCertContext)
		{
			// Setup
			bool addRefed = false;
			global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates __value;
			global::System.IntPtr unsafe___value;
			// Marshalling
			hCertStore.DangerousAddRef(ref addRefed);
			__value = new global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates();
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.crypt32_dll_PInvokes.CertEnumCertificatesInStore(
								hCertStore.DangerousGetHandle(), 
								((global::Internal_Cryptography_Pal_Native.CERT_CONTEXT__System_Security_Cryptography_X509Certificates*)pPrevCertContext)
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								__value, 
								unsafe___value
							);
			if (addRefed)
				hCertStore.DangerousRelease();
			// Return
			return __value;
		}

		// Signature, CertGetNameString, [fwd] [return] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00043474] Internal_Cryptography_Pal_Native_SafeCertContextHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [EETypeRva:0x00042D30] Internal_Cryptography_Pal_Native_CertNameType__System_Security_Cryptography_X509Certificates__CertNameType__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00042D30] Internal_Cryptography_Pal_Native_CertNameFlags__System_Security_Cryptography_X509Certificates__CertNameFlags__System_Security_Cryptography_X509Certificates, [fwd] [in] [managedbyref] [nativebyref] [EETypeRva:0x00042D30] Internal_Cryptography_Pal_Native_CertNameStringType__System_Security_Cryptography_X509Certificates__CertNameStringType__System_Security_Cryptography_X509Certificates, [fwd] [out] [EETypeRva:0x00041CC4] System_Text_StringBuilder__wchar_t *, [fwd] [in] [EETypeRva:0x00041980] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertGetNameString")]
		public static int CertGetNameString(
					global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates pCertContext, 
					global::Internal_Cryptography_Pal_Native.CertNameType__System_Security_Cryptography_X509Certificates dwType, 
					global::Internal_Cryptography_Pal_Native.CertNameFlags__System_Security_Cryptography_X509Certificates dwFlags, 
					ref global::Internal_Cryptography_Pal_Native.CertNameStringType__System_Security_Cryptography_X509Certificates pvTypePara, 
					global::System.Text.StringBuilder pszNameString, 
					int cchNameString)
		{
			// Setup
			bool addRefed = false;
			ushort* unsafe_pszNameString = default(ushort*);
			int unsafe___value;
			try
			{
				// Marshalling
				pCertContext.DangerousAddRef(ref addRefed);
				fixed (global::Internal_Cryptography_Pal_Native.CertNameStringType__System_Security_Cryptography_X509Certificates* pinned_pvTypePara = &(pvTypePara))
				{
					if (pszNameString == null)
						unsafe_pszNameString = null;
					else
					{
						unsafe_pszNameString = (ushort*)global::System.Runtime.InteropServices.McgMarshal.CoTaskMemAllocAndZeroMemory(new global::System.IntPtr(checked(pszNameString.Capacity * 2 
											+ 2)));
						if (unsafe_pszNameString == null)
							throw new global::System.OutOfMemoryException();
					}
					global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
					// Call to native method
					unsafe___value = global::__Interop.crypt32_dll_PInvokes.CertGetNameString(
										pCertContext.DangerousGetHandle(), 
										dwType, 
										dwFlags, 
										pinned_pvTypePara, 
										unsafe_pszNameString, 
										cchNameString
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
					if (pszNameString != null)
						global::System.Runtime.InteropServices.McgMarshal.UnicodeStringToStringBuilder(
											unsafe_pszNameString, 
											pszNameString
										);
				}
				if (addRefed)
					pCertContext.DangerousRelease();
				// Return
				return unsafe___value;
			}
			finally
			{
				// Cleanup
				if (unsafe_pszNameString != null)
					global::System.Runtime.InteropServices.McgMarshal.SafeCoTaskMemFree(unsafe_pszNameString);
			}
		}

		// Signature, CertGetNameString__0, [fwd] [return] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00043474] Internal_Cryptography_Pal_Native_SafeCertContextHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [EETypeRva:0x00042D30] Internal_Cryptography_Pal_Native_CertNameType__System_Security_Cryptography_X509Certificates__CertNameType__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00042D30] Internal_Cryptography_Pal_Native_CertNameFlags__System_Security_Cryptography_X509Certificates__CertNameFlags__System_Security_Cryptography_X509Certificates, [fwd] [in] [managedbyref] [nativebyref] [EETypeRva:0x00042D30] Internal_Cryptography_Pal_Native_CertNameStrTypeAndFlags__System_Security_Cryptography_X509Certificates__CertNameStrTypeAndFlags__System_Security_Cryptography_X509Certificates, [fwd] [out] [EETypeRva:0x00041CC4] System_Text_StringBuilder__wchar_t *, [fwd] [in] [EETypeRva:0x00041980] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertGetNameString")]
		public static int CertGetNameString__0(
					global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates pCertContext, 
					global::Internal_Cryptography_Pal_Native.CertNameType__System_Security_Cryptography_X509Certificates dwType, 
					global::Internal_Cryptography_Pal_Native.CertNameFlags__System_Security_Cryptography_X509Certificates dwFlags, 
					ref global::Internal_Cryptography_Pal_Native.CertNameStrTypeAndFlags__System_Security_Cryptography_X509Certificates pvPara, 
					global::System.Text.StringBuilder pszNameString, 
					int cchNameString)
		{
			// Setup
			bool addRefed = false;
			ushort* unsafe_pszNameString = default(ushort*);
			int unsafe___value;
			try
			{
				// Marshalling
				pCertContext.DangerousAddRef(ref addRefed);
				fixed (global::Internal_Cryptography_Pal_Native.CertNameStrTypeAndFlags__System_Security_Cryptography_X509Certificates* pinned_pvPara = &(pvPara))
				{
					if (pszNameString == null)
						unsafe_pszNameString = null;
					else
					{
						unsafe_pszNameString = (ushort*)global::System.Runtime.InteropServices.McgMarshal.CoTaskMemAllocAndZeroMemory(new global::System.IntPtr(checked(pszNameString.Capacity * 2 
											+ 2)));
						if (unsafe_pszNameString == null)
							throw new global::System.OutOfMemoryException();
					}
					global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
					// Call to native method
					unsafe___value = global::__Interop.crypt32_dll_PInvokes.CertGetNameString__0(
										pCertContext.DangerousGetHandle(), 
										dwType, 
										dwFlags, 
										pinned_pvPara, 
										unsafe_pszNameString, 
										cchNameString
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
					if (pszNameString != null)
						global::System.Runtime.InteropServices.McgMarshal.UnicodeStringToStringBuilder(
											unsafe_pszNameString, 
											pszNameString
										);
				}
				if (addRefed)
					pCertContext.DangerousRelease();
				// Return
				return unsafe___value;
			}
			finally
			{
				// Cleanup
				if (unsafe_pszNameString != null)
					global::System.Runtime.InteropServices.McgMarshal.SafeCoTaskMemFree(unsafe_pszNameString);
			}
		}

		// Signature, CryptFindOIDInfo__0, [fwd] [return] [EETypeRva:0x00041980] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00042D30] __Interop_Crypt32_CryptOidInfoKeyType__System_Security_Cryptography_X509Certificates__Interop_Crypt32_CryptOidInfoKeyType__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00042D30] System_Security_Cryptography_OidGroup__System_Security_Cryptography_Encoding__OidGroup__System_Security_Cryptography_Encoding, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+Crypt32", "CryptFindOIDInfo")]
		public static global::System.IntPtr CryptFindOIDInfo__0(
					global::_.Interop_Crypt32_CryptOidInfoKeyType__System_Security_Cryptography_X509Certificates dwKeyType, 
					global::System.IntPtr pvKey, 
					global::System_Security_Cryptography.OidGroup__System_Security_Cryptography_Encoding group)
		{
			// Setup
			global::System.IntPtr unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop.crypt32_dll_PInvokes.CryptFindOIDInfo__0(
								dwKeyType, 
								pvKey, 
								group
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, CertGetCertificateChain, [fwd] [return] [EETypeRva:0x00040818] bool__System.Boolean, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00043474] Internal_Cryptography_Pal_Native_SafeCertContextHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [EETypeRva:0x00041980] Internal_Cryptography_Pal_Native_FILETIME__System_Security_Cryptography_X509Certificates___ptrInternal_Cryptography_Pal_Native__FILETIME__System_Security_Cryptography_X509Certificates *, [fwd] [in] [EETypeRva:0x00043474] Internal_Cryptography_Pal_Native_SafeCertStoreHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [managedbyref] [nativebyref] [EETypeRva:0x0004311C] Internal_Cryptography_Pal_Native_CERT_CHAIN_PARA__System_Security_Cryptography_X509Certificates__Internal_Cryptography_Pal_Native__CERT_CHAIN_PARA__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00042D30] Internal_Cryptography_Pal_Native_CertChainFlags__System_Security_Cryptography_X509Certificates__CertChainFlags__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x00043474] Microsoft_Win32_SafeHandles_SafeX509ChainHandle__System_Security_Cryptography_X509Certificates____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertGetCertificateChain")]
		public static bool CertGetCertificateChain(
					global::System.IntPtr hChainEngine, 
					global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates pCertContext, 
					global::Internal_Cryptography_Pal_Native.FILETIME__System_Security_Cryptography_X509Certificates* pTime, 
					global::Internal.Cryptography.Pal.Native.SafeCertStoreHandle__System_Security_Cryptography_X509Certificates hStore, 
					ref global::Internal_Cryptography_Pal_Native.CERT_CHAIN_PARA__System_Security_Cryptography_X509Certificates pChainPara, 
					global::Internal_Cryptography_Pal_Native.CertChainFlags__System_Security_Cryptography_X509Certificates dwFlags, 
					global::System.IntPtr pvReserved, 
					out global::Microsoft.Win32.SafeHandles.SafeX509ChainHandle__System_Security_Cryptography_X509Certificates ppChainContext)
		{
			// Setup
			bool addRefed = false;
			bool addRefed_1 = false;
			global::System.IntPtr unsafe_ppChainContext;
			int unsafe___value;
			// Marshalling
			pCertContext.DangerousAddRef(ref addRefed);
			hStore.DangerousAddRef(ref addRefed_1);
			fixed (global::Internal_Cryptography_Pal_Native.CERT_CHAIN_PARA__System_Security_Cryptography_X509Certificates* pinned_pChainPara = &(pChainPara))
			{
				ppChainContext = new global::Microsoft.Win32.SafeHandles.SafeX509ChainHandle__System_Security_Cryptography_X509Certificates();
				unsafe_ppChainContext = ppChainContext.DangerousGetHandle();
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.crypt32_dll_PInvokes.CertGetCertificateChain(
									hChainEngine, 
									pCertContext.DangerousGetHandle(), 
									((global::Internal_Cryptography_Pal_Native.FILETIME__System_Security_Cryptography_X509Certificates*)pTime), 
									hStore.DangerousGetHandle(), 
									pinned_pChainPara, 
									dwFlags, 
									pvReserved, 
									&(unsafe_ppChainContext)
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
									ppChainContext, 
									unsafe_ppChainContext
								);
			}
			if (addRefed_1)
				hStore.DangerousRelease();
			if (addRefed)
				pCertContext.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CertVerifyCertificateChainPolicy, [fwd] [return] [EETypeRva:0x00040818] bool__System.Boolean, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00043474] Microsoft_Win32_SafeHandles_SafeX509ChainHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [managedbyref] [nativebyref] [EETypeRva:0x0004311C] Internal_Cryptography_Pal_Native_CERT_CHAIN_POLICY_PARA__System_Security_Cryptography_X509Certificates__Internal_Cryptography_Pal_Native__CERT_CHAIN_POLICY_PARA__System_Security_Cryptography_X509Certificates, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x0004311C] Internal_Cryptography_Pal_Native_CERT_CHAIN_POLICY_STATUS__System_Security_Cryptography_X509Certificates__Internal_Cryptography_Pal_Native__CERT_CHAIN_POLICY_STATUS__System_Security_Cryptography_X509Certificates, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertVerifyCertificateChainPolicy")]
		public static bool CertVerifyCertificateChainPolicy(
					global::System.IntPtr pszPolicyOID, 
					global::Microsoft.Win32.SafeHandles.SafeX509ChainHandle__System_Security_Cryptography_X509Certificates pChainContext, 
					ref global::Internal_Cryptography_Pal_Native.CERT_CHAIN_POLICY_PARA__System_Security_Cryptography_X509Certificates pPolicyPara, 
					ref global::Internal_Cryptography_Pal_Native.CERT_CHAIN_POLICY_STATUS__System_Security_Cryptography_X509Certificates pPolicyStatus)
		{
			// Setup
			bool addRefed = false;
			int unsafe___value;
			// Marshalling
			pChainContext.DangerousAddRef(ref addRefed);
			fixed (global::Internal_Cryptography_Pal_Native.CERT_CHAIN_POLICY_PARA__System_Security_Cryptography_X509Certificates* pinned_pPolicyPara = &(pPolicyPara))
				fixed (global::Internal_Cryptography_Pal_Native.CERT_CHAIN_POLICY_STATUS__System_Security_Cryptography_X509Certificates* pinned_pPolicyStatus = &(pPolicyStatus))
				{
					global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
					// Call to native method
					unsafe___value = global::__Interop.crypt32_dll_PInvokes.CertVerifyCertificateChainPolicy(
										pszPolicyOID, 
										pChainContext.DangerousGetHandle(), 
										pinned_pPolicyPara, 
										pinned_pPolicyStatus
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				}
			if (addRefed)
				pChainContext.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CertNameToStr, [fwd] [return] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00042D30] Internal_Cryptography_Pal_Native_CertEncodingType__System_Security_Cryptography_X509Certificates__CertEncodingType__System_Security_Cryptography_X509Certificates, [fwd] [in] [managedbyref] [nativebyref] [EETypeRva:0x0004311C] Internal_Cryptography_Pal_Native_CRYPTOAPI_BLOB__System_Security_Cryptography_X509Certificates__Internal_Cryptography_Pal_Native__CRYPTOAPI_BLOB__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00042D30] Internal_Cryptography_Pal_Native_CertNameStrTypeAndFlags__System_Security_Cryptography_X509Certificates__CertNameStrTypeAndFlags__System_Security_Cryptography_X509Certificates, [fwd] [in] [out] [EETypeRva:0x00041CC4] System_Text_StringBuilder__wchar_t *, [fwd] [in] [EETypeRva:0x00041980] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertNameToStr")]
		public static int CertNameToStr(
					global::Internal_Cryptography_Pal_Native.CertEncodingType__System_Security_Cryptography_X509Certificates dwCertEncodingType, 
					ref global::Internal_Cryptography_Pal_Native.CRYPTOAPI_BLOB__System_Security_Cryptography_X509Certificates pName, 
					global::Internal_Cryptography_Pal_Native.CertNameStrTypeAndFlags__System_Security_Cryptography_X509Certificates dwStrType, 
					global::System.Text.StringBuilder psz, 
					int csz)
		{
			// Setup
			ushort* unsafe_psz = default(ushort*);
			int unsafe___value;
			try
			{
				// Marshalling
				fixed (global::Internal_Cryptography_Pal_Native.CRYPTOAPI_BLOB__System_Security_Cryptography_X509Certificates* pinned_pName = &(pName))
				{
					if (psz == null)
						unsafe_psz = null;
					else
					{
						unsafe_psz = (ushort*)global::System.Runtime.InteropServices.McgMarshal.CoTaskMemAllocAndZeroMemory(new global::System.IntPtr(checked(psz.Capacity * 2 
											+ 2)));
						if (unsafe_psz == null)
							throw new global::System.OutOfMemoryException();
					}
					if (unsafe_psz != null)
						global::System.Runtime.InteropServices.McgMarshal.StringBuilderToUnicodeString(
											psz, 
											unsafe_psz
										);
					global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
					// Call to native method
					unsafe___value = global::__Interop.crypt32_dll_PInvokes.CertNameToStr(
										dwCertEncodingType, 
										pinned_pName, 
										dwStrType, 
										unsafe_psz, 
										csz
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
					if (psz != null)
						global::System.Runtime.InteropServices.McgMarshal.UnicodeStringToStringBuilder(
											unsafe_psz, 
											psz
										);
				}
				// Return
				return unsafe___value;
			}
			finally
			{
				// Cleanup
				if (unsafe_psz != null)
					global::System.Runtime.InteropServices.McgMarshal.SafeCoTaskMemFree(unsafe_psz);
			}
		}

		// Signature, CryptFormatObject, [fwd] [return] [EETypeRva:0x00040818] bool__System.Boolean, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00041C00] string__unsigned char *, [fwd] [in] [EETypeRva:0x00042A10] rg_byte__unsigned char *, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [out] [EETypeRva:0x00041CC4] System_Text_StringBuilder__wchar_t *, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x00041980] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Encoding, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Internal.NativeCrypto.Cng+Interop", "CryptFormatObject")]
		public static bool CryptFormatObject(
					int dwCertEncodingType, 
					int dwFormatType, 
					int dwFormatStrType, 
					global::System.IntPtr pFormatStruct, 
					string lpszStructType, 
					byte[] pbEncoded, 
					int cbEncoded, 
					global::System.Text.StringBuilder pbFormat, 
					ref int pcbFormat)
		{
			// Setup
			byte* unsafe_lpszStructType = default(byte*);
			byte* unsafe_pbEncoded;
			ushort* unsafe_pbFormat = default(ushort*);
			int unsafe___value;
			try
			{
				// Marshalling
				unsafe_lpszStructType = global::System.Runtime.InteropServices.McgMarshal.StringToAnsiString(lpszStructType, false, false);
				fixed (byte* pinned_pbEncoded = ((pbEncoded != null 
							&& pbEncoded.Length == 0) ? new byte[1] : pbEncoded))
				{
					unsafe_pbEncoded = (byte*)pinned_pbEncoded;
					if (pbFormat == null)
						unsafe_pbFormat = null;
					else
					{
						unsafe_pbFormat = (ushort*)global::System.Runtime.InteropServices.McgMarshal.CoTaskMemAllocAndZeroMemory(new global::System.IntPtr(checked(pbFormat.Capacity * 2 
											+ 2)));
						if (unsafe_pbFormat == null)
							throw new global::System.OutOfMemoryException();
					}
					fixed (int* pinned_pcbFormat = &(pcbFormat))
					{
						global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
						// Call to native method
						unsafe___value = global::__Interop.crypt32_dll_PInvokes.CryptFormatObject(
											dwCertEncodingType, 
											dwFormatType, 
											dwFormatStrType, 
											pFormatStruct, 
											unsafe_lpszStructType, 
											unsafe_pbEncoded, 
											cbEncoded, 
											unsafe_pbFormat, 
											pinned_pcbFormat
										);
						global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
						global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
					}
					if (pbFormat != null)
						global::System.Runtime.InteropServices.McgMarshal.UnicodeStringToStringBuilder(
											unsafe_pbFormat, 
											pbFormat
										);
				}
				// Return
				return unsafe___value != 0;
			}
			finally
			{
				// Cleanup
				global::System.Runtime.InteropServices.McgMarshal.SafeCoTaskMemFree(unsafe_lpszStructType);
				if (unsafe_pbFormat != null)
					global::System.Runtime.InteropServices.McgMarshal.SafeCoTaskMemFree(unsafe_pbFormat);
			}
		}

		// Signature, CertAddCertificateLinkToStore, [fwd] [return] [EETypeRva:0x00040818] bool__System.Boolean, [fwd] [in] [EETypeRva:0x00043474] Internal_Cryptography_Pal_Native_SafeCertStoreHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [EETypeRva:0x00043474] Internal_Cryptography_Pal_Native_SafeCertContextHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [EETypeRva:0x00042D30] Internal_Cryptography_Pal_Native_CertStoreAddDisposition__System_Security_Cryptography_X509Certificates__CertStoreAddDisposition__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertAddCertificateLinkToStore")]
		public static bool CertAddCertificateLinkToStore(
					global::Internal.Cryptography.Pal.Native.SafeCertStoreHandle__System_Security_Cryptography_X509Certificates hCertStore, 
					global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates pCertContext, 
					global::Internal_Cryptography_Pal_Native.CertStoreAddDisposition__System_Security_Cryptography_X509Certificates dwAddDisposition, 
					global::System.IntPtr ppStoreContext)
		{
			// Setup
			bool addRefed = false;
			bool addRefed_1 = false;
			int unsafe___value;
			// Marshalling
			hCertStore.DangerousAddRef(ref addRefed);
			pCertContext.DangerousAddRef(ref addRefed_1);
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.crypt32_dll_PInvokes.CertAddCertificateLinkToStore(
								hCertStore.DangerousGetHandle(), 
								pCertContext.DangerousGetHandle(), 
								dwAddDisposition, 
								ppStoreContext
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			if (addRefed_1)
				pCertContext.DangerousRelease();
			if (addRefed)
				hCertStore.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CryptFormatObject__0, [fwd] [return] [EETypeRva:0x00040818] bool__System.Boolean, [fwd] [in] [EETypeRva:0x00042D30] Internal_Cryptography_Pal_Native_CertEncodingType__System_Security_Cryptography_X509Certificates__CertEncodingType__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00042D30] Internal_Cryptography_Pal_Native_FormatObjectType__System_Security_Cryptography_X509Certificates__FormatObjectType__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00042D30] Internal_Cryptography_Pal_Native_FormatObjectStringType__System_Security_Cryptography_X509Certificates__FormatObjectStringType__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00042A10] rg_byte__unsigned char *, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [out] [EETypeRva:0x00041CC4] System_Text_StringBuilder__wchar_t *, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x00041980] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CryptFormatObject")]
		public static bool CryptFormatObject__0(
					global::Internal_Cryptography_Pal_Native.CertEncodingType__System_Security_Cryptography_X509Certificates dwCertEncodingType, 
					global::Internal_Cryptography_Pal_Native.FormatObjectType__System_Security_Cryptography_X509Certificates dwFormatType, 
					global::Internal_Cryptography_Pal_Native.FormatObjectStringType__System_Security_Cryptography_X509Certificates dwFormatStrType, 
					global::System.IntPtr pFormatStruct, 
					global::System.IntPtr lpszStructType, 
					byte[] pbEncoded, 
					int cbEncoded, 
					global::System.Text.StringBuilder pbFormat, 
					ref int pcbFormat)
		{
			// Setup
			byte* unsafe_pbEncoded;
			ushort* unsafe_pbFormat = default(ushort*);
			int unsafe___value;
			try
			{
				// Marshalling
				fixed (byte* pinned_pbEncoded = ((pbEncoded != null 
							&& pbEncoded.Length == 0) ? new byte[1] : pbEncoded))
				{
					unsafe_pbEncoded = (byte*)pinned_pbEncoded;
					if (pbFormat == null)
						unsafe_pbFormat = null;
					else
					{
						unsafe_pbFormat = (ushort*)global::System.Runtime.InteropServices.McgMarshal.CoTaskMemAllocAndZeroMemory(new global::System.IntPtr(checked(pbFormat.Capacity * 2 
											+ 2)));
						if (unsafe_pbFormat == null)
							throw new global::System.OutOfMemoryException();
					}
					fixed (int* pinned_pcbFormat = &(pcbFormat))
					{
						global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
						// Call to native method
						unsafe___value = global::__Interop.crypt32_dll_PInvokes.CryptFormatObject__0(
											dwCertEncodingType, 
											dwFormatType, 
											dwFormatStrType, 
											pFormatStruct, 
											lpszStructType, 
											unsafe_pbEncoded, 
											cbEncoded, 
											unsafe_pbFormat, 
											pinned_pcbFormat
										);
						global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
						global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
					}
					if (pbFormat != null)
						global::System.Runtime.InteropServices.McgMarshal.UnicodeStringToStringBuilder(
											unsafe_pbFormat, 
											pbFormat
										);
				}
				// Return
				return unsafe___value != 0;
			}
			finally
			{
				// Cleanup
				if (unsafe_pbFormat != null)
					global::System.Runtime.InteropServices.McgMarshal.SafeCoTaskMemFree(unsafe_pbFormat);
			}
		}

		// Signature, CertOpenStore, [fwd] [return] [EETypeRva:0x00043474] Internal_Cryptography_Pal_Native_SafeCertStoreHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00042D30] Internal_Cryptography_Pal_Native_CertEncodingType__System_Security_Cryptography_X509Certificates__CertEncodingType__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00042D30] Internal_Cryptography_Pal_Native_CertStoreFlags__System_Security_Cryptography_X509Certificates__CertStoreFlags__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00041B14] string__wchar_t *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertOpenStore")]
		public static global::Internal.Cryptography.Pal.Native.SafeCertStoreHandle__System_Security_Cryptography_X509Certificates CertOpenStore(
					global::System.IntPtr lpszStoreProvider, 
					global::Internal_Cryptography_Pal_Native.CertEncodingType__System_Security_Cryptography_X509Certificates dwMsgAndCertEncodingType, 
					global::System.IntPtr hCryptProv, 
					global::Internal_Cryptography_Pal_Native.CertStoreFlags__System_Security_Cryptography_X509Certificates dwFlags, 
					string pvPara)
		{
			// Setup
			ushort* unsafe_pvPara = default(ushort*);
			global::Internal.Cryptography.Pal.Native.SafeCertStoreHandle__System_Security_Cryptography_X509Certificates __value;
			global::System.IntPtr unsafe___value;
			// Marshalling
			fixed (char* pinned_pvPara = pvPara)
			{
				unsafe_pvPara = (ushort*)pinned_pvPara;
				__value = new global::Internal.Cryptography.Pal.Native.SafeCertStoreHandle__System_Security_Cryptography_X509Certificates();
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.crypt32_dll_PInvokes.CertOpenStore(
									lpszStoreProvider, 
									dwMsgAndCertEncodingType, 
									hCryptProv, 
									dwFlags, 
									unsafe_pvPara
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
									__value, 
									unsafe___value
								);
			}
			// Return
			return __value;
		}

		// Signature, CryptImportPublicKeyInfoEx2, [fwd] [return] [EETypeRva:0x00040818] bool__System.Boolean, [fwd] [in] [EETypeRva:0x00042D30] Internal_Cryptography_Pal_Native_CertEncodingType__System_Security_Cryptography_X509Certificates__CertEncodingType__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00041980] Internal_Cryptography_Pal_Native_CERT_PUBLIC_KEY_INFO__System_Security_Cryptography_X509Certificates___ptrInternal_Cryptography_Pal_Native__CERT_PUBLIC_KEY_INFO__System_Security_Cryptography_X509Certificates *, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] void___ptrvoid *, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x00043474] Microsoft_Win32_SafeHandles_SafeBCryptKeyHandle__System_Security_Cryptography_X509Certificates____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CryptImportPublicKeyInfoEx2")]
		public static bool CryptImportPublicKeyInfoEx2(
					global::Internal_Cryptography_Pal_Native.CertEncodingType__System_Security_Cryptography_X509Certificates dwCertEncodingType, 
					global::Internal_Cryptography_Pal_Native.CERT_PUBLIC_KEY_INFO__System_Security_Cryptography_X509Certificates* pInfo, 
					int dwFlags, 
					void* pvAuxInfo, 
					out global::Microsoft.Win32.SafeHandles.SafeBCryptKeyHandle__System_Security_Cryptography_X509Certificates phKey)
		{
			// Setup
			global::System.IntPtr unsafe_phKey;
			int unsafe___value;
			// Marshalling
			phKey = new global::Microsoft.Win32.SafeHandles.SafeBCryptKeyHandle__System_Security_Cryptography_X509Certificates();
			unsafe_phKey = phKey.DangerousGetHandle();
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.crypt32_dll_PInvokes.CryptImportPublicKeyInfoEx2(
								dwCertEncodingType, 
								((global::Internal_Cryptography_Pal_Native.CERT_PUBLIC_KEY_INFO__System_Security_Cryptography_X509Certificates*)pInfo), 
								dwFlags, 
								((void*)pvAuxInfo), 
								&(unsafe_phKey)
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								phKey, 
								unsafe_phKey
							);
			// Return
			return unsafe___value != 0;
		}

		// Signature, CryptDecodeObject, [fwd] [return] [EETypeRva:0x00040818] bool__System.Boolean, [fwd] [in] [EETypeRva:0x00042D30] Internal_Cryptography_Pal_Native_CertEncodingType__System_Security_Cryptography_X509Certificates__CertEncodingType__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00042A10] rg_byte__unsigned char *, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00042D30] Internal_Cryptography_Pal_Native_CryptDecodeObjectFlags__System_Security_Cryptography_X509Certificates__CryptDecodeObjectFlags__System_Security_Cryptography_X509Certificates, [fwd] [out] [EETypeRva:0x00042A10] rg_byte__unsigned char *, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x00041980] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CryptDecodeObject")]
		public static bool CryptDecodeObject(
					global::Internal_Cryptography_Pal_Native.CertEncodingType__System_Security_Cryptography_X509Certificates dwCertEncodingType, 
					global::System.IntPtr lpszStructType, 
					byte[] pbEncoded, 
					int cbEncoded, 
					global::Internal_Cryptography_Pal_Native.CryptDecodeObjectFlags__System_Security_Cryptography_X509Certificates dwFlags, 
					byte[] pvStructInfo, 
					ref int pcbStructInfo)
		{
			// Setup
			byte* unsafe_pbEncoded;
			byte* unsafe_pvStructInfo;
			int unsafe___value;
			// Marshalling
			fixed (byte* pinned_pbEncoded = ((pbEncoded != null 
						&& pbEncoded.Length == 0) ? new byte[1] : pbEncoded))
			{
				unsafe_pbEncoded = (byte*)pinned_pbEncoded;
				fixed (byte* pinned_pvStructInfo = ((pvStructInfo != null 
							&& pvStructInfo.Length == 0) ? new byte[1] : pvStructInfo))
				{
					unsafe_pvStructInfo = (byte*)pinned_pvStructInfo;
					fixed (int* pinned_pcbStructInfo = &(pcbStructInfo))
					{
						global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
						// Call to native method
						unsafe___value = global::__Interop.crypt32_dll_PInvokes.CryptDecodeObject(
											dwCertEncodingType, 
											lpszStructType, 
											unsafe_pbEncoded, 
											cbEncoded, 
											dwFlags, 
											unsafe_pvStructInfo, 
											pinned_pcbStructInfo
										);
						global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
						global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
					}
				}
			}
			// Return
			return unsafe___value != 0;
		}

		// Signature, CertFreeCertificateChain, [fwd] [return] [EETypeRva:0x00041F3C] void__void, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertFreeCertificateChain")]
		public static void CertFreeCertificateChain(global::System.IntPtr pChainContext)
		{
			// Marshalling
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			global::__Interop.crypt32_dll_PInvokes.CertFreeCertificateChain(pChainContext);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
		}

		// Signature, CertControlStore, [fwd] [return] [EETypeRva:0x00040818] bool__System.Boolean, [fwd] [in] [EETypeRva:0x00043474] Internal_Cryptography_Pal_Native_SafeCertStoreHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [EETypeRva:0x00042D30] Internal_Cryptography_Pal_Native_CertControlStoreFlags__System_Security_Cryptography_X509Certificates__CertControlStoreFlags__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00042D30] Internal_Cryptography_Pal_Native_CertControlStoreType__System_Security_Cryptography_X509Certificates__CertControlStoreType__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertControlStore")]
		public static bool CertControlStore(
					global::Internal.Cryptography.Pal.Native.SafeCertStoreHandle__System_Security_Cryptography_X509Certificates hCertStore, 
					global::Internal_Cryptography_Pal_Native.CertControlStoreFlags__System_Security_Cryptography_X509Certificates dwFlags, 
					global::Internal_Cryptography_Pal_Native.CertControlStoreType__System_Security_Cryptography_X509Certificates dwControlType, 
					global::System.IntPtr pvCtrlPara)
		{
			// Setup
			bool addRefed = false;
			int unsafe___value;
			// Marshalling
			hCertStore.DangerousAddRef(ref addRefed);
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.crypt32_dll_PInvokes.CertControlStore(
								hCertStore.DangerousGetHandle(), 
								dwFlags, 
								dwControlType, 
								pvCtrlPara
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			if (addRefed)
				hCertStore.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CryptDecodeObjectPointer, [fwd] [return] [EETypeRva:0x00040818] bool__System.Boolean, [fwd] [in] [EETypeRva:0x00042D30] Internal_Cryptography_Pal_Native_CertEncodingType__System_Security_Cryptography_X509Certificates__CertEncodingType__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00042A10] rg_byte__unsigned char *, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00042D30] Internal_Cryptography_Pal_Native_CryptDecodeObjectFlags__System_Security_Cryptography_X509Certificates__CryptDecodeObjectFlags__System_Security_Cryptography_X509Certificates, [fwd] [out] [EETypeRva:0x00041980] void___ptrvoid *, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x00041980] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CryptDecodeObjectPointer")]
		public static bool CryptDecodeObjectPointer(
					global::Internal_Cryptography_Pal_Native.CertEncodingType__System_Security_Cryptography_X509Certificates dwCertEncodingType, 
					global::System.IntPtr lpszStructType, 
					byte[] pbEncoded, 
					int cbEncoded, 
					global::Internal_Cryptography_Pal_Native.CryptDecodeObjectFlags__System_Security_Cryptography_X509Certificates dwFlags, 
					void* pvStructInfo, 
					ref int pcbStructInfo)
		{
			// Setup
			byte* unsafe_pbEncoded;
			int unsafe___value;
			// Marshalling
			fixed (byte* pinned_pbEncoded = ((pbEncoded != null 
						&& pbEncoded.Length == 0) ? new byte[1] : pbEncoded))
			{
				unsafe_pbEncoded = (byte*)pinned_pbEncoded;
				fixed (int* pinned_pcbStructInfo = &(pcbStructInfo))
				{
					global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
					// Call to native method
					unsafe___value = global::__Interop.crypt32_dll_PInvokes.CryptDecodeObjectPointer(
										dwCertEncodingType, 
										lpszStructType, 
										unsafe_pbEncoded, 
										cbEncoded, 
										dwFlags, 
										((void*)pvStructInfo), 
										pinned_pcbStructInfo
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				}
			}
			// Return
			return unsafe___value != 0;
		}

		// Signature, CertFindExtension, [fwd] [return] [EETypeRva:0x00041980] Internal_Cryptography_Pal_Native_CERT_EXTENSION__System_Security_Cryptography_X509Certificates___ptrInternal_Cryptography_Pal_Native__CERT_EXTENSION__System_Security_Cryptography_X509Certificates *, [fwd] [in] [EETypeRva:0x00041C00] string__unsigned char *, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] Internal_Cryptography_Pal_Native_CERT_EXTENSION__System_Security_Cryptography_X509Certificates___ptrInternal_Cryptography_Pal_Native__CERT_EXTENSION__System_Security_Cryptography_X509Certificates *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertFindExtension")]
		public static global::Internal_Cryptography_Pal_Native.CERT_EXTENSION__System_Security_Cryptography_X509Certificates* CertFindExtension(
					string pszObjId, 
					int cExtensions, 
					global::Internal_Cryptography_Pal_Native.CERT_EXTENSION__System_Security_Cryptography_X509Certificates* rgExtensions)
		{
			// Setup
			byte* unsafe_pszObjId = default(byte*);
			global::Internal_Cryptography_Pal_Native.CERT_EXTENSION__System_Security_Cryptography_X509Certificates* unsafe___value;
			try
			{
				// Marshalling
				unsafe_pszObjId = global::System.Runtime.InteropServices.McgMarshal.StringToAnsiString(pszObjId, true, false);
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = (global::Internal_Cryptography_Pal_Native.CERT_EXTENSION__System_Security_Cryptography_X509Certificates*)global::__Interop.crypt32_dll_PInvokes.CertFindExtension(
									unsafe_pszObjId, 
									cExtensions, 
									((global::Internal_Cryptography_Pal_Native.CERT_EXTENSION__System_Security_Cryptography_X509Certificates*)rgExtensions)
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				// Return
				return (global::Internal_Cryptography_Pal_Native.CERT_EXTENSION__System_Security_Cryptography_X509Certificates*)unsafe___value;
			}
			finally
			{
				// Cleanup
				global::System.Runtime.InteropServices.McgMarshal.SafeCoTaskMemFree(unsafe_pszObjId);
			}
		}

		// Signature, CertGetValidUsages, [fwd] [return] [EETypeRva:0x00040818] bool__System.Boolean, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [managedbyref] [nativebyref] [EETypeRva:0x00043474] Internal_Cryptography_Pal_Native_SafeCertContextHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x00041980] int__int, [fwd] [out] [EETypeRva:0x00041980] void___ptrvoid *, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x00041980] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertGetValidUsages")]
		public static bool CertGetValidUsages(
					int cCerts, 
					ref global::Internal.Cryptography.Pal.Native.SafeCertContextHandle__System_Security_Cryptography_X509Certificates rghCerts, 
					out int cNumOIDs, 
					void* rghOIDs, 
					ref int pcbOIDs)
		{
			// Setup
			bool addRefed = false;
			global::System.IntPtr unsafe_rghCerts;
			int unsafe___value;
			// Marshalling
			rghCerts.DangerousAddRef(ref addRefed);
			unsafe_rghCerts = rghCerts.DangerousGetHandle();
			fixed (int* pinned_cNumOIDs = &(cNumOIDs))
				fixed (int* pinned_pcbOIDs = &(pcbOIDs))
				{
					global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
					// Call to native method
					unsafe___value = global::__Interop.crypt32_dll_PInvokes.CertGetValidUsages(
										cCerts, 
										&(unsafe_rghCerts), 
										pinned_cNumOIDs, 
										((void*)rghOIDs), 
										pinned_pcbOIDs
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				}
			if (addRefed)
				rghCerts.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CertGetIntendedKeyUsage, [fwd] [return] [EETypeRva:0x00040818] bool__System.Boolean, [fwd] [in] [EETypeRva:0x00042D30] Internal_Cryptography_Pal_Native_CertEncodingType__System_Security_Cryptography_X509Certificates__CertEncodingType__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00041980] Internal_Cryptography_Pal_Native_CERT_INFO__System_Security_Cryptography_X509Certificates___ptrInternal_Cryptography_Pal_Native__CERT_INFO__System_Security_Cryptography_X509Certificates *, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x00042D30] System_Security_Cryptography_X509Certificates_X509KeyUsageFlags__System_Security_Cryptography_X509Certificates__X509KeyUsageFlags__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00041980] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertGetIntendedKeyUsage")]
		public static bool CertGetIntendedKeyUsage(
					global::Internal_Cryptography_Pal_Native.CertEncodingType__System_Security_Cryptography_X509Certificates dwCertEncodingType, 
					global::Internal_Cryptography_Pal_Native.CERT_INFO__System_Security_Cryptography_X509Certificates* pCertInfo, 
					out global::System_Security_Cryptography_X509Certificates.X509KeyUsageFlags__System_Security_Cryptography_X509Certificates pbKeyUsage, 
					int cbKeyUsage)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			fixed (global::System_Security_Cryptography_X509Certificates.X509KeyUsageFlags__System_Security_Cryptography_X509Certificates* pinned_pbKeyUsage = &(pbKeyUsage))
			{
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.crypt32_dll_PInvokes.CertGetIntendedKeyUsage(
									dwCertEncodingType, 
									((global::Internal_Cryptography_Pal_Native.CERT_INFO__System_Security_Cryptography_X509Certificates*)pCertInfo), 
									pinned_pbKeyUsage, 
									cbKeyUsage
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			// Return
			return unsafe___value != 0;
		}

		// Signature, CryptFindOIDInfo__1, [fwd] [return] [EETypeRva:0x00041980] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00042D30] __Interop_Crypt32_CryptOidInfoKeyType__System_Security_Cryptography_Cng__Interop_Crypt32_CryptOidInfoKeyType__System_Security_Cryptography_Cng, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00042D30] System_Security_Cryptography_OidGroup__System_Security_Cryptography_Encoding__OidGroup__System_Security_Cryptography_Encoding, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Cng, Version=4.3.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Crypt32", "CryptFindOIDInfo")]
		public static global::System.IntPtr CryptFindOIDInfo__1(
					global::_.Interop_Crypt32_CryptOidInfoKeyType__System_Security_Cryptography_Cng dwKeyType, 
					global::System.IntPtr pvKey, 
					global::System_Security_Cryptography.OidGroup__System_Security_Cryptography_Encoding group)
		{
			// Setup
			global::System.IntPtr unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop.crypt32_dll_PInvokes.CryptFindOIDInfo__1(
								dwKeyType, 
								pvKey, 
								group
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, CertVerifyTimeValidity, [fwd] [return] [EETypeRva:0x00041980] int__int, [fwd] [in] [managedbyref] [nativebyref] [EETypeRva:0x0004311C] Internal_Cryptography_Pal_Native_FILETIME__System_Security_Cryptography_X509Certificates__Internal_Cryptography_Pal_Native__FILETIME__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00041980] Internal_Cryptography_Pal_Native_CERT_INFO__System_Security_Cryptography_X509Certificates___ptrInternal_Cryptography_Pal_Native__CERT_INFO__System_Security_Cryptography_X509Certificates *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+crypt32", "CertVerifyTimeValidity")]
		public static int CertVerifyTimeValidity(
					ref global::Internal_Cryptography_Pal_Native.FILETIME__System_Security_Cryptography_X509Certificates pTimeToVerify, 
					global::Internal_Cryptography_Pal_Native.CERT_INFO__System_Security_Cryptography_X509Certificates* pCertInfo)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			fixed (global::Internal_Cryptography_Pal_Native.FILETIME__System_Security_Cryptography_X509Certificates* pinned_pTimeToVerify = &(pTimeToVerify))
			{
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.crypt32_dll_PInvokes.CertVerifyTimeValidity(
									pinned_pTimeToVerify, 
									((global::Internal_Cryptography_Pal_Native.CERT_INFO__System_Security_Cryptography_X509Certificates*)pCertInfo)
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			// Return
			return unsafe___value;
		}
	}

	/// <summary>
	/// P/Invoke class for module 'kernel32.dll'
	/// </summary>
	public unsafe static partial class kernel32_dll
	{
		// Signature, GetCPInfoExW, [fwd] [return] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] uint__unsigned int, [fwd] [in] [EETypeRva:0x00041980] uint__unsigned int, [fwd] [in] [EETypeRva:0x00041980] __Interop_Kernel32_CPINFOEXW__System_Text_Encoding_CodePages___ptr__Interop_Kernel32_CPINFOEXW__System_Text_Encoding_CodePages *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Text.Encoding.CodePages, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Kernel32", "GetCPInfoExW")]
		public static int GetCPInfoExW(
					uint CodePage, 
					uint dwFlags, 
					global::_.Interop_Kernel32_CPINFOEXW__System_Text_Encoding_CodePages* lpCPInfoEx)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop.kernel32_dll_PInvokes.GetCPInfoExW(
								CodePage, 
								dwFlags, 
								((global::_.Interop_Kernel32_CPINFOEXW__System_Text_Encoding_CodePages*)lpCPInfoEx)
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, FormatMessage, [fwd] [return] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00041980] uint__unsigned int, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] char___ptrwchar_t *, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00042A10] rg_System_IntPtr____w64 int *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+Kernel32", "FormatMessage")]
		public static int FormatMessage(
					int dwFlags, 
					global::System.IntPtr lpSource, 
					uint dwMessageId, 
					int dwLanguageId, 
					char* lpBuffer, 
					int nSize, 
					global::System.IntPtr[] arguments)
		{
			// Setup
			global::System.IntPtr* unsafe_arguments;
			int unsafe___value;
			// Marshalling
			fixed (global::System.IntPtr* pinned_arguments = ((arguments != null 
						&& arguments.Length == 0) ? new global::System.IntPtr[1] : arguments))
			{
				unsafe_arguments = (global::System.IntPtr*)pinned_arguments;
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.kernel32_dll_PInvokes.FormatMessage(
									dwFlags, 
									lpSource, 
									dwMessageId, 
									dwLanguageId, 
									((ushort*)lpBuffer), 
									nSize, 
									unsafe_arguments
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			// Return
			return unsafe___value;
		}

		// Signature, LocalAlloc, [fwd] [return] [EETypeRva:0x00043474] Microsoft_Win32_SafeHandles_SafeLocalAllocHandle__System_Net_Primitives____w64 int, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] System_UIntPtr____w64 unsigned int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Primitives, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Kernel32", "LocalAlloc")]
		public static global::Microsoft.Win32.SafeHandles.SafeLocalAllocHandle__System_Net_Primitives LocalAlloc(
					int uFlags, 
					global::System.UIntPtr sizetdwBytes)
		{
			// Setup
			global::Microsoft.Win32.SafeHandles.SafeLocalAllocHandle__System_Net_Primitives __value;
			global::System.IntPtr unsafe___value;
			// Marshalling
			__value = new global::Microsoft.Win32.SafeHandles.SafeLocalAllocHandle__System_Net_Primitives();
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.kernel32_dll_PInvokes.LocalAlloc(
								uFlags, 
								sizetdwBytes
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								__value, 
								unsafe___value
							);
			// Return
			return __value;
		}

		// Signature, LocalFree, [fwd] [return] [EETypeRva:0x00041980] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Primitives, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Kernel32", "LocalFree")]
		public static global::System.IntPtr LocalFree(global::System.IntPtr handle)
		{
			// Setup
			global::System.IntPtr unsafe___value;
			// Marshalling
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.kernel32_dll_PInvokes.LocalFree(handle);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value;
		}

		// Signature, FormatMessage__0, [fwd] [return] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00041980] uint__unsigned int, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] char___ptrwchar_t *, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00042A10] rg_System_IntPtr____w64 int *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Cng, Version=4.3.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Kernel32", "FormatMessage")]
		public static int FormatMessage__0(
					int dwFlags, 
					global::System.IntPtr lpSource, 
					uint dwMessageId, 
					int dwLanguageId, 
					char* lpBuffer, 
					int nSize, 
					global::System.IntPtr[] arguments)
		{
			// Setup
			global::System.IntPtr* unsafe_arguments;
			int unsafe___value;
			// Marshalling
			fixed (global::System.IntPtr* pinned_arguments = ((arguments != null 
						&& arguments.Length == 0) ? new global::System.IntPtr[1] : arguments))
			{
				unsafe_arguments = (global::System.IntPtr*)pinned_arguments;
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.kernel32_dll_PInvokes.FormatMessage__0(
									dwFlags, 
									lpSource, 
									dwMessageId, 
									dwLanguageId, 
									((ushort*)lpBuffer), 
									nSize, 
									unsafe_arguments
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			// Return
			return unsafe___value;
		}

		// Signature, FormatMessage__1, [fwd] [return] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00041980] uint__unsigned int, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] char___ptrwchar_t *, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00042A10] rg_System_IntPtr____w64 int *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Csp, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Kernel32", "FormatMessage")]
		public static int FormatMessage__1(
					int dwFlags, 
					global::System.IntPtr lpSource, 
					uint dwMessageId, 
					int dwLanguageId, 
					char* lpBuffer, 
					int nSize, 
					global::System.IntPtr[] arguments)
		{
			// Setup
			global::System.IntPtr* unsafe_arguments;
			int unsafe___value;
			// Marshalling
			fixed (global::System.IntPtr* pinned_arguments = ((arguments != null 
						&& arguments.Length == 0) ? new global::System.IntPtr[1] : arguments))
			{
				unsafe_arguments = (global::System.IntPtr*)pinned_arguments;
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.kernel32_dll_PInvokes.FormatMessage__1(
									dwFlags, 
									lpSource, 
									dwMessageId, 
									dwLanguageId, 
									((ushort*)lpBuffer), 
									nSize, 
									unsafe_arguments
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			// Return
			return unsafe___value;
		}

		// Signature, FormatMessage__2, [fwd] [return] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00041980] uint__unsigned int, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] char___ptrwchar_t *, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00042A10] rg_System_IntPtr____w64 int *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("Microsoft.Win32.Primitives, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Kernel32", "FormatMessage")]
		public static int FormatMessage__2(
					int dwFlags, 
					global::System.IntPtr lpSource, 
					uint dwMessageId, 
					int dwLanguageId, 
					char* lpBuffer, 
					int nSize, 
					global::System.IntPtr[] arguments)
		{
			// Setup
			global::System.IntPtr* unsafe_arguments;
			int unsafe___value;
			// Marshalling
			fixed (global::System.IntPtr* pinned_arguments = ((arguments != null 
						&& arguments.Length == 0) ? new global::System.IntPtr[1] : arguments))
			{
				unsafe_arguments = (global::System.IntPtr*)pinned_arguments;
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.kernel32_dll_PInvokes.FormatMessage__2(
									dwFlags, 
									lpSource, 
									dwMessageId, 
									dwLanguageId, 
									((ushort*)lpBuffer), 
									nSize, 
									unsafe_arguments
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			// Return
			return unsafe___value;
		}

		// Signature, FormatMessage__3, [fwd] [return] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00041980] uint__unsigned int, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] char___ptrwchar_t *, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00042A10] rg_System_IntPtr____w64 int *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Algorithms, Version=4.3.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Kernel32", "FormatMessage")]
		public static int FormatMessage__3(
					int dwFlags, 
					global::System.IntPtr lpSource, 
					uint dwMessageId, 
					int dwLanguageId, 
					char* lpBuffer, 
					int nSize, 
					global::System.IntPtr[] arguments)
		{
			// Setup
			global::System.IntPtr* unsafe_arguments;
			int unsafe___value;
			// Marshalling
			fixed (global::System.IntPtr* pinned_arguments = ((arguments != null 
						&& arguments.Length == 0) ? new global::System.IntPtr[1] : arguments))
			{
				unsafe_arguments = (global::System.IntPtr*)pinned_arguments;
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.kernel32_dll_PInvokes.FormatMessage__3(
									dwFlags, 
									lpSource, 
									dwMessageId, 
									dwLanguageId, 
									((ushort*)lpBuffer), 
									nSize, 
									unsafe_arguments
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			// Return
			return unsafe___value;
		}
	}

	/// <summary>
	/// P/Invoke class for module 'api-ms-win-core-com-l1-1-0.dll'
	/// </summary>
	public unsafe static partial class api_ms_win_core_com_l1_1_0_dll
	{
		// Signature, CoCreateInstance, [fwd] [return] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] byte___ptrunsigned char *, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] byte___ptrunsigned char *, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x00041980] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.StackTraceGenerator, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Internal.StackTraceGenerator.StackTraceGenerator", "CoCreateInstance")]
		public static int CoCreateInstance(
					byte* rclsid, 
					global::System.IntPtr pUnkOuter, 
					int dwClsContext, 
					byte* riid, 
					out global::System.IntPtr ppv)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			fixed (global::System.IntPtr* pinned_ppv = &(ppv))
			{
				// Call to native method
				unsafe___value = global::__Interop.api_ms_win_core_com_l1_1_0_dll_PInvokes.CoCreateInstance(
									((byte*)rclsid), 
									pUnkOuter, 
									dwClsContext, 
									((byte*)riid), 
									pinned_ppv
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			}
			// Return
			return unsafe___value;
		}
	}

	/// <summary>
	/// P/Invoke class for module 'advapi32.dll'
	/// </summary>
	public unsafe static partial class advapi32_dll
	{
		// Signature, CryptAcquireContext, [fwd] [return] [EETypeRva:0x00040818] bool__System.Boolean, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x00041980] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00041980] char___ptrwchar_t *, [fwd] [in] [EETypeRva:0x00041980] char___ptrwchar_t *, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00042D30] Internal_Cryptography_Pal_Native_CryptAcquireContextFlags__System_Security_Cryptography_X509Certificates__CryptAcquireContextFlags__System_Security_Cryptography_X509Certificates, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+cryptoapi", "CryptAcquireContext")]
		public static bool CryptAcquireContext(
					out global::System.IntPtr psafeProvHandle, 
					char* pszContainer, 
					char* pszProvider, 
					int dwProvType, 
					global::Internal_Cryptography_Pal_Native.CryptAcquireContextFlags__System_Security_Cryptography_X509Certificates dwFlags)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			fixed (global::System.IntPtr* pinned_psafeProvHandle = &(psafeProvHandle))
			{
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.advapi32_dll_PInvokes.CryptAcquireContext(
									pinned_psafeProvHandle, 
									((ushort*)pszContainer), 
									((ushort*)pszProvider), 
									dwProvType, 
									dwFlags
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			// Return
			return unsafe___value != 0;
		}

		// Signature, CryptGetKeyParam, [fwd] [return] [EETypeRva:0x00040818] bool__System.Boolean, [fwd] [in] [EETypeRva:0x00043474] System_Security_Cryptography_SafeKeyHandle__System_Security_Cryptography_Csp____w64 int, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00042A10] rg_byte__unsigned char *, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Csp, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Internal.NativeCrypto.CapiHelper+Interop", "CryptGetKeyParam")]
		public static bool CryptGetKeyParam(
					global::System.Security.Cryptography.SafeKeyHandle__System_Security_Cryptography_Csp safeKeyHandle, 
					int dwParam, 
					byte[] pbData, 
					ref int pdwDataLen, 
					int dwFlags)
		{
			// Setup
			bool addRefed = false;
			byte* unsafe_pbData;
			int unsafe___value;
			// Marshalling
			safeKeyHandle.DangerousAddRef(ref addRefed);
			fixed (byte* pinned_pbData = ((pbData != null 
						&& pbData.Length == 0) ? new byte[1] : pbData))
			{
				unsafe_pbData = (byte*)pinned_pbData;
				fixed (int* pinned_pdwDataLen = &(pdwDataLen))
				{
					global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
					// Call to native method
					unsafe___value = global::__Interop.advapi32_dll_PInvokes.CryptGetKeyParam(
										safeKeyHandle.DangerousGetHandle(), 
										dwParam, 
										unsafe_pbData, 
										pinned_pdwDataLen, 
										dwFlags
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				}
			}
			if (addRefed)
				safeKeyHandle.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CryptGetDefaultProvider, [fwd] [return] [EETypeRva:0x00040818] bool__System.Boolean, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [out] [EETypeRva:0x00041CC4] System_Text_StringBuilder__wchar_t *, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x00041980] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Csp, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Internal.NativeCrypto.CapiHelper+Interop", "CryptGetDefaultProvider")]
		public static bool CryptGetDefaultProvider(
					int dwProvType, 
					global::System.IntPtr pdwReserved, 
					int dwFlags, 
					global::System.Text.StringBuilder pszProvName, 
					ref int IntPtrProvName)
		{
			// Setup
			ushort* unsafe_pszProvName = default(ushort*);
			int unsafe___value;
			try
			{
				// Marshalling
				if (pszProvName == null)
					unsafe_pszProvName = null;
				else
				{
					unsafe_pszProvName = (ushort*)global::System.Runtime.InteropServices.McgMarshal.CoTaskMemAllocAndZeroMemory(new global::System.IntPtr(checked(pszProvName.Capacity * 2 
										+ 2)));
					if (unsafe_pszProvName == null)
						throw new global::System.OutOfMemoryException();
				}
				if (unsafe_pszProvName != null)
					global::System.Runtime.InteropServices.McgMarshal.StringBuilderToUnicodeString(
										pszProvName, 
										unsafe_pszProvName
									);
				fixed (int* pinned_IntPtrProvName = &(IntPtrProvName))
				{
					global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
					// Call to native method
					unsafe___value = global::__Interop.advapi32_dll_PInvokes.CryptGetDefaultProvider(
										dwProvType, 
										pdwReserved, 
										dwFlags, 
										unsafe_pszProvName, 
										pinned_IntPtrProvName
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				}
				if (pszProvName != null)
					global::System.Runtime.InteropServices.McgMarshal.UnicodeStringToStringBuilder(
										unsafe_pszProvName, 
										pszProvName
									);
				// Return
				return unsafe___value != 0;
			}
			finally
			{
				// Cleanup
				if (unsafe_pszProvName != null)
					global::System.Runtime.InteropServices.McgMarshal.SafeCoTaskMemFree(unsafe_pszProvName);
			}
		}

		// Signature, CryptAcquireContext__0, [fwd] [return] [EETypeRva:0x00040818] bool__System.Boolean, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x00043474] System_Security_Cryptography_SafeProvHandle__System_Security_Cryptography_Csp____w64 int, [fwd] [in] [EETypeRva:0x00041B14] string__wchar_t *, [fwd] [in] [EETypeRva:0x00041B14] string__wchar_t *, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] uint__unsigned int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Csp, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Internal.NativeCrypto.CapiHelper+Interop", "CryptAcquireContext")]
		public static bool CryptAcquireContext__0(
					out global::System.Security.Cryptography.SafeProvHandle__System_Security_Cryptography_Csp psafeProvHandle, 
					string pszContainer, 
					string pszProvider, 
					int dwProvType, 
					uint dwFlags)
		{
			// Setup
			global::System.IntPtr unsafe_psafeProvHandle;
			ushort* unsafe_pszContainer = default(ushort*);
			ushort* unsafe_pszProvider = default(ushort*);
			int unsafe___value;
			// Marshalling
			psafeProvHandle = new global::System.Security.Cryptography.SafeProvHandle__System_Security_Cryptography_Csp();
			unsafe_psafeProvHandle = psafeProvHandle.DangerousGetHandle();
			fixed (char* pinned_pszContainer = pszContainer)
			{
				unsafe_pszContainer = (ushort*)pinned_pszContainer;
				fixed (char* pinned_pszProvider = pszProvider)
				{
					unsafe_pszProvider = (ushort*)pinned_pszProvider;
					global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
					// Call to native method
					unsafe___value = global::__Interop.advapi32_dll_PInvokes.CryptAcquireContext__0(
										&(unsafe_psafeProvHandle), 
										unsafe_pszContainer, 
										unsafe_pszProvider, 
										dwProvType, 
										dwFlags
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				}
			}
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								psafeProvHandle, 
								unsafe_psafeProvHandle
							);
			// Return
			return unsafe___value != 0;
		}

		// Signature, _CryptGetUserKey, [fwd] [return] [EETypeRva:0x00040818] bool__System.Boolean, [fwd] [in] [EETypeRva:0x00043474] System_Security_Cryptography_SafeProvHandle__System_Security_Cryptography_Csp____w64 int, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x00043474] System_Security_Cryptography_SafeKeyHandle__System_Security_Cryptography_Csp____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Csp, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Internal.NativeCrypto.CapiHelper+Interop", "_CryptGetUserKey")]
		public static bool _CryptGetUserKey(
					global::System.Security.Cryptography.SafeProvHandle__System_Security_Cryptography_Csp safeProvHandle, 
					int dwKeySpec, 
					out global::System.Security.Cryptography.SafeKeyHandle__System_Security_Cryptography_Csp safeKeyHandle)
		{
			// Setup
			bool addRefed = false;
			global::System.IntPtr unsafe_safeKeyHandle;
			int unsafe___value;
			// Marshalling
			safeProvHandle.DangerousAddRef(ref addRefed);
			safeKeyHandle = new global::System.Security.Cryptography.SafeKeyHandle__System_Security_Cryptography_Csp();
			unsafe_safeKeyHandle = safeKeyHandle.DangerousGetHandle();
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.advapi32_dll_PInvokes._CryptGetUserKey(
								safeProvHandle.DangerousGetHandle(), 
								dwKeySpec, 
								&(unsafe_safeKeyHandle)
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								safeKeyHandle, 
								unsafe_safeKeyHandle
							);
			if (addRefed)
				safeProvHandle.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CryptGetProvParam, [fwd] [return] [EETypeRva:0x00040818] bool__System.Boolean, [fwd] [in] [EETypeRva:0x00043474] System_Runtime_InteropServices_SafeHandle____w64 int, [fwd] [in] [EETypeRva:0x00042D30] __Interop_Advapi32_CryptProvParam__System_Security_Cryptography_Csp__Interop_Advapi32_CryptProvParam__System_Security_Cryptography_Csp, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Csp, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Advapi32", "CryptGetProvParam")]
		public static bool CryptGetProvParam(
					global::System.Runtime.InteropServices.SafeHandle safeProvHandle, 
					global::_.Interop_Advapi32_CryptProvParam__System_Security_Cryptography_Csp dwParam, 
					global::System.IntPtr pbData, 
					ref int dwDataLen, 
					int dwFlags)
		{
			// Setup
			bool addRefed = false;
			int unsafe___value;
			// Marshalling
			safeProvHandle.DangerousAddRef(ref addRefed);
			fixed (int* pinned_dwDataLen = &(dwDataLen))
			{
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.advapi32_dll_PInvokes.CryptGetProvParam(
									safeProvHandle.DangerousGetHandle(), 
									dwParam, 
									pbData, 
									pinned_dwDataLen, 
									dwFlags
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			if (addRefed)
				safeProvHandle.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CryptDestroyKey, [fwd] [return] [EETypeRva:0x00040818] bool__System.Boolean, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Csp, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Internal.NativeCrypto.CapiHelper+Interop", "CryptDestroyKey")]
		public static bool CryptDestroyKey(global::System.IntPtr hKey)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.advapi32_dll_PInvokes.CryptDestroyKey(hKey);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CryptReleaseContext, [fwd] [return] [EETypeRva:0x00040818] bool__System.Boolean, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00041980] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Csp, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Internal.NativeCrypto.CapiHelper+Interop", "CryptReleaseContext")]
		public static bool CryptReleaseContext(
					global::System.IntPtr safeProvHandle, 
					int dwFlags)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.advapi32_dll_PInvokes.CryptReleaseContext(
								safeProvHandle, 
								dwFlags
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value != 0;
		}

		// Signature, _CryptImportKey, [fwd] [return] [EETypeRva:0x00040818] bool__System.Boolean, [fwd] [in] [EETypeRva:0x00043474] System_Security_Cryptography_SafeProvHandle__System_Security_Cryptography_Csp____w64 int, [fwd] [in] [EETypeRva:0x00042A10] rg_byte__unsigned char *, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00043474] System_Security_Cryptography_SafeKeyHandle__System_Security_Cryptography_Csp____w64 int, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x00043474] System_Security_Cryptography_SafeKeyHandle__System_Security_Cryptography_Csp____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Csp, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Internal.NativeCrypto.CapiHelper+Interop", "_CryptImportKey")]
		public static bool _CryptImportKey(
					global::System.Security.Cryptography.SafeProvHandle__System_Security_Cryptography_Csp hProv, 
					byte[] pbData, 
					int dwDataLen, 
					global::System.Security.Cryptography.SafeKeyHandle__System_Security_Cryptography_Csp hPubKey, 
					int dwFlags, 
					out global::System.Security.Cryptography.SafeKeyHandle__System_Security_Cryptography_Csp phKey)
		{
			// Setup
			bool addRefed = false;
			byte* unsafe_pbData;
			bool addRefed_1 = false;
			global::System.IntPtr unsafe_phKey;
			int unsafe___value;
			// Marshalling
			hProv.DangerousAddRef(ref addRefed);
			fixed (byte* pinned_pbData = ((pbData != null 
						&& pbData.Length == 0) ? new byte[1] : pbData))
			{
				unsafe_pbData = (byte*)pinned_pbData;
				hPubKey.DangerousAddRef(ref addRefed_1);
				phKey = new global::System.Security.Cryptography.SafeKeyHandle__System_Security_Cryptography_Csp();
				unsafe_phKey = phKey.DangerousGetHandle();
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.advapi32_dll_PInvokes._CryptImportKey(
									hProv.DangerousGetHandle(), 
									unsafe_pbData, 
									dwDataLen, 
									hPubKey.DangerousGetHandle(), 
									dwFlags, 
									&(unsafe_phKey)
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
									phKey, 
									unsafe_phKey
								);
				if (addRefed_1)
					hPubKey.DangerousRelease();
			}
			if (addRefed)
				hProv.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CryptSetProvParamIndirectPtr, [fwd] [return] [EETypeRva:0x00040818] bool__System.Boolean, [fwd] [in] [EETypeRva:0x00043474] System_Security_Cryptography_SafeProvHandle__System_Security_Cryptography_Csp____w64 int, [fwd] [in] [EETypeRva:0x00042D30] __Interop_Advapi32_CryptProvParam__System_Security_Cryptography_Csp__Interop_Advapi32_CryptProvParam__System_Security_Cryptography_Csp, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x00041980] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00041980] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Csp, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Internal.NativeCrypto.CapiHelper+Interop", "CryptSetProvParamIndirectPtr")]
		public static bool CryptSetProvParamIndirectPtr(
					global::System.Security.Cryptography.SafeProvHandle__System_Security_Cryptography_Csp safeProvHandle, 
					global::_.Interop_Advapi32_CryptProvParam__System_Security_Cryptography_Csp dwParam, 
					ref global::System.IntPtr pbData, 
					int dwFlags)
		{
			// Setup
			bool addRefed = false;
			int unsafe___value;
			// Marshalling
			safeProvHandle.DangerousAddRef(ref addRefed);
			fixed (global::System.IntPtr* pinned_pbData = &(pbData))
			{
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.advapi32_dll_PInvokes.CryptSetProvParamIndirectPtr(
									safeProvHandle.DangerousGetHandle(), 
									dwParam, 
									pinned_pbData, 
									dwFlags
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			if (addRefed)
				safeProvHandle.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CryptSetProvParam, [fwd] [return] [EETypeRva:0x00040818] bool__System.Boolean, [fwd] [in] [EETypeRva:0x00043474] System_Runtime_InteropServices_SafeHandle____w64 int, [fwd] [in] [EETypeRva:0x00042D30] __Interop_Advapi32_CryptProvParam__System_Security_Cryptography_Csp__Interop_Advapi32_CryptProvParam__System_Security_Cryptography_Csp, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00041980] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Csp, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Advapi32", "CryptSetProvParam")]
		public static bool CryptSetProvParam(
					global::System.Runtime.InteropServices.SafeHandle safeProvHandle, 
					global::_.Interop_Advapi32_CryptProvParam__System_Security_Cryptography_Csp dwParam, 
					global::System.IntPtr pbData, 
					int dwFlags)
		{
			// Setup
			bool addRefed = false;
			int unsafe___value;
			// Marshalling
			safeProvHandle.DangerousAddRef(ref addRefed);
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.advapi32_dll_PInvokes.CryptSetProvParam(
								safeProvHandle.DangerousGetHandle(), 
								dwParam, 
								pbData, 
								dwFlags
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			if (addRefed)
				safeProvHandle.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, _CryptGenKey, [fwd] [return] [EETypeRva:0x00040818] bool__System.Boolean, [fwd] [in] [EETypeRva:0x00043474] System_Security_Cryptography_SafeProvHandle__System_Security_Cryptography_Csp____w64 int, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x00043474] System_Security_Cryptography_SafeKeyHandle__System_Security_Cryptography_Csp____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Csp, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Internal.NativeCrypto.CapiHelper+Interop", "_CryptGenKey")]
		public static bool _CryptGenKey(
					global::System.Security.Cryptography.SafeProvHandle__System_Security_Cryptography_Csp safeProvHandle, 
					int Algid, 
					int dwFlags, 
					out global::System.Security.Cryptography.SafeKeyHandle__System_Security_Cryptography_Csp safeKeyHandle)
		{
			// Setup
			bool addRefed = false;
			global::System.IntPtr unsafe_safeKeyHandle;
			int unsafe___value;
			// Marshalling
			safeProvHandle.DangerousAddRef(ref addRefed);
			safeKeyHandle = new global::System.Security.Cryptography.SafeKeyHandle__System_Security_Cryptography_Csp();
			unsafe_safeKeyHandle = safeKeyHandle.DangerousGetHandle();
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.advapi32_dll_PInvokes._CryptGenKey(
								safeProvHandle.DangerousGetHandle(), 
								Algid, 
								dwFlags, 
								&(unsafe_safeKeyHandle)
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								safeKeyHandle, 
								unsafe_safeKeyHandle
							);
			if (addRefed)
				safeProvHandle.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}
	}

	/// <summary>
	/// P/Invoke class for module 'ws2_32.dll'
	/// </summary>
	public unsafe static partial class ws2_32_dll
	{
		// Signature, WSAGetOverlappedResult, [fwd] [return] [EETypeRva:0x00040818] bool__System.Boolean, [fwd] [in] [EETypeRva:0x00043474] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [EETypeRva:0x00041980] System_Threading_NativeOverlapped__System_Private_CoreLib___ptrSystem_Threading__NativeOverlapped__System_Private_CoreLib *, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x00041980] uint__unsigned int, [fwd] [in] [EETypeRva:0x00040818] bool__System.Boolean, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x00042D30] System_Net_Sockets_SocketFlags__System_Net_Sockets__SocketFlags__System_Net_Sockets, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "WSAGetOverlappedResult")]
		public static bool WSAGetOverlappedResult(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					global::System_Threading.NativeOverlapped__System_Private_CoreLib* overlapped, 
					out uint bytesTransferred, 
					bool wait, 
					out global::System_Net_Sockets.SocketFlags__System_Net_Sockets socketFlags)
		{
			// Setup
			bool addRefed = false;
			int unsafe___value;
			// Marshalling
			socketHandle.DangerousAddRef(ref addRefed);
			fixed (uint* pinned_bytesTransferred = &(bytesTransferred))
				fixed (global::System_Net_Sockets.SocketFlags__System_Net_Sockets* pinned_socketFlags = &(socketFlags))
				{
					global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
					// Call to native method
					unsafe___value = global::__Interop.ws2_32_dll_PInvokes.WSAGetOverlappedResult(
										socketHandle.DangerousGetHandle(), 
										((global::System_Threading.NativeOverlapped__System_Private_CoreLib*)overlapped), 
										pinned_bytesTransferred, 
										(wait ? 1 : 0), 
										pinned_socketFlags
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				}
			if (addRefed)
				socketHandle.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, setsockopt, [fwd] [return] [EETypeRva:0x00042D30] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [EETypeRva:0x00043474] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [EETypeRva:0x00042D30] System_Net_Sockets_SocketOptionLevel__System_Net_Sockets__SocketOptionLevel__System_Net_Sockets, [fwd] [in] [EETypeRva:0x00042D30] System_Net_Sockets_SocketOptionName__System_Net_Sockets__SocketOptionName__System_Net_Sockets, [fwd] [in] [managedbyref] [nativebyref] [EETypeRva:0x00041980] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00041980] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "setsockopt")]
		public static global::System_Net_Sockets.SocketError__System_Net_Primitives setsockopt(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					global::System_Net_Sockets.SocketOptionLevel__System_Net_Sockets optionLevel, 
					global::System_Net_Sockets.SocketOptionName__System_Net_Sockets optionName, 
					ref global::System.IntPtr pointer, 
					int optionLength)
		{
			// Setup
			bool addRefed = false;
			global::System_Net_Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			socketHandle.DangerousAddRef(ref addRefed);
			fixed (global::System.IntPtr* pinned_pointer = &(pointer))
			{
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.ws2_32_dll_PInvokes.setsockopt(
									socketHandle.DangerousGetHandle(), 
									optionLevel, 
									optionName, 
									pinned_pointer, 
									optionLength
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			if (addRefed)
				socketHandle.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, setsockopt__0, [fwd] [return] [EETypeRva:0x00042D30] System_Net_Sockets_SocketError__System_Net_Primitives__SocketError__System_Net_Primitives, [fwd] [in] [EETypeRva:0x00043474] System_Net_Sockets_SafeCloseSocket__System_Net_Sockets____w64 int, [fwd] [in] [EETypeRva:0x00042D30] System_Net_Sockets_SocketOptionLevel__System_Net_Sockets__SocketOptionLevel__System_Net_Sockets, [fwd] [in] [EETypeRva:0x00042D30] System_Net_Sockets_SocketOptionName__System_Net_Sockets__SocketOptionName__System_Net_Sockets, [fwd] [in] [EETypeRva:0x00042A10] rg_byte__unsigned char *, [fwd] [in] [EETypeRva:0x00041980] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Sockets, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Winsock", "setsockopt")]
		public static global::System_Net_Sockets.SocketError__System_Net_Primitives setsockopt__0(
					global::System.Net.Sockets.SafeCloseSocket__System_Net_Sockets socketHandle, 
					global::System_Net_Sockets.SocketOptionLevel__System_Net_Sockets optionLevel, 
					global::System_Net_Sockets.SocketOptionName__System_Net_Sockets optionName, 
					byte[] optionValue, 
					int optionLength)
		{
			// Setup
			bool addRefed = false;
			byte* unsafe_optionValue;
			global::System_Net_Sockets.SocketError__System_Net_Primitives unsafe___value;
			// Marshalling
			socketHandle.DangerousAddRef(ref addRefed);
			fixed (byte* pinned_optionValue = ((optionValue != null 
						&& optionValue.Length == 0) ? new byte[1] : optionValue))
			{
				unsafe_optionValue = (byte*)pinned_optionValue;
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.ws2_32_dll_PInvokes.setsockopt__0(
									socketHandle.DangerousGetHandle(), 
									optionLevel, 
									optionName, 
									unsafe_optionValue, 
									optionLength
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			if (addRefed)
				socketHandle.DangerousRelease();
			// Return
			return unsafe___value;
		}
	}

	/// <summary>
	/// P/Invoke class for module 'OleAut32'
	/// </summary>
	public unsafe static partial class OleAut32
	{
		// Signature, SysFreeString, [fwd] [return] [EETypeRva:0x00041F3C] void__void, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.StackTraceGenerator, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Internal.LightweightInterop.MarshalExtensions", "SysFreeString")]
		public static void SysFreeString(global::System.IntPtr bstr)
		{
			// Marshalling
			// Call to native method
			global::__Interop.OleAut32_PInvokes.SysFreeString(bstr);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
		}
	}

	/// <summary>
	/// P/Invoke class for module 'ncrypt.dll'
	/// </summary>
	public unsafe static partial class ncrypt_dll
	{
		// Signature, NCryptOpenKey, [fwd] [return] [EETypeRva:0x00042D30] __Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng__Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng, [fwd] [in] [EETypeRva:0x00043474] Microsoft_Win32_SafeHandles_SafeNCryptProviderHandle__System_Security_Cryptography_Cng____w64 int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x00043474] Microsoft_Win32_SafeHandles_SafeNCryptKeyHandle__System_Security_Cryptography_Cng____w64 int, [fwd] [in] [EETypeRva:0x00041B14] string__wchar_t *, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00042D30] System_Security_Cryptography_CngKeyOpenOptions__System_Security_Cryptography_Cng__CngKeyOpenOptions__System_Security_Cryptography_Cng, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Cng, Version=4.3.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+NCrypt", "NCryptOpenKey")]
		public static global::_.Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng NCryptOpenKey(
					global::Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle__System_Security_Cryptography_Cng hProvider, 
					out global::Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle__System_Security_Cryptography_Cng phKey, 
					string pszKeyName, 
					int dwLegacyKeySpec, 
					global::System_Security_Cryptography.CngKeyOpenOptions__System_Security_Cryptography_Cng dwFlags)
		{
			// Setup
			bool addRefed = false;
			global::System.IntPtr unsafe_phKey;
			ushort* unsafe_pszKeyName = default(ushort*);
			global::_.Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng unsafe___value;
			// Marshalling
			hProvider.DangerousAddRef(ref addRefed);
			phKey = new global::Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle__System_Security_Cryptography_Cng();
			unsafe_phKey = phKey.DangerousGetHandle();
			fixed (char* pinned_pszKeyName = pszKeyName)
			{
				unsafe_pszKeyName = (ushort*)pinned_pszKeyName;
				// Call to native method
				unsafe___value = global::__Interop.ncrypt_dll_PInvokes.NCryptOpenKey(
									hProvider.DangerousGetHandle(), 
									&(unsafe_phKey), 
									unsafe_pszKeyName, 
									dwLegacyKeySpec, 
									dwFlags
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			}
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								phKey, 
								unsafe_phKey
							);
			if (addRefed)
				hProvider.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, NCryptDeleteKey, [fwd] [return] [EETypeRva:0x00042D30] __Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng__Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng, [fwd] [in] [EETypeRva:0x00043474] Microsoft_Win32_SafeHandles_SafeNCryptKeyHandle__System_Security_Cryptography_Cng____w64 int, [fwd] [in] [EETypeRva:0x00041980] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Cng, Version=4.3.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+NCrypt", "NCryptDeleteKey")]
		public static global::_.Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng NCryptDeleteKey(
					global::Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle__System_Security_Cryptography_Cng hKey, 
					int dwFlags)
		{
			// Setup
			bool addRefed = false;
			global::_.Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng unsafe___value;
			// Marshalling
			hKey.DangerousAddRef(ref addRefed);
			// Call to native method
			unsafe___value = global::__Interop.ncrypt_dll_PInvokes.NCryptDeleteKey(
								hKey.DangerousGetHandle(), 
								dwFlags
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			if (addRefed)
				hKey.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, NCryptOpenStorageProvider, [fwd] [return] [EETypeRva:0x00042D30] __Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng__Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x00043474] Microsoft_Win32_SafeHandles_SafeNCryptProviderHandle__System_Security_Cryptography_Cng____w64 int, [fwd] [in] [EETypeRva:0x00041B14] string__wchar_t *, [fwd] [in] [EETypeRva:0x00041980] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Cng, Version=4.3.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+NCrypt", "NCryptOpenStorageProvider")]
		public static global::_.Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng NCryptOpenStorageProvider(
					out global::Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle__System_Security_Cryptography_Cng phProvider, 
					string pszProviderName, 
					int dwFlags)
		{
			// Setup
			global::System.IntPtr unsafe_phProvider;
			ushort* unsafe_pszProviderName = default(ushort*);
			global::_.Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng unsafe___value;
			// Marshalling
			phProvider = new global::Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle__System_Security_Cryptography_Cng();
			unsafe_phProvider = phProvider.DangerousGetHandle();
			fixed (char* pinned_pszProviderName = pszProviderName)
			{
				unsafe_pszProviderName = (ushort*)pinned_pszProviderName;
				// Call to native method
				unsafe___value = global::__Interop.ncrypt_dll_PInvokes.NCryptOpenStorageProvider(
									&(unsafe_phProvider), 
									unsafe_pszProviderName, 
									dwFlags
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			}
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								phProvider, 
								unsafe_phProvider
							);
			// Return
			return unsafe___value;
		}

		// Signature, NCryptFreeObject, [fwd] [return] [EETypeRva:0x00042D30] __Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng__Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Cng, Version=4.3.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+NCrypt", "NCryptFreeObject")]
		public static global::_.Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng NCryptFreeObject(global::System.IntPtr hObject)
		{
			// Setup
			global::_.Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop.ncrypt_dll_PInvokes.NCryptFreeObject(hObject);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, NCryptImportKey, [fwd] [return] [EETypeRva:0x00042D30] __Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng__Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng, [fwd] [in] [EETypeRva:0x00043474] Microsoft_Win32_SafeHandles_SafeNCryptProviderHandle__System_Security_Cryptography_Cng____w64 int, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00041B14] string__wchar_t *, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x00043474] Microsoft_Win32_SafeHandles_SafeNCryptKeyHandle__System_Security_Cryptography_Cng____w64 int, [fwd] [in] [EETypeRva:0x00042A10] rg_byte__unsigned char *, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Cng, Version=4.3.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+NCrypt", "NCryptImportKey")]
		public static global::_.Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng NCryptImportKey(
					global::Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle__System_Security_Cryptography_Cng hProvider, 
					global::System.IntPtr hImportKey, 
					string pszBlobType, 
					global::System.IntPtr pParameterList, 
					out global::Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle__System_Security_Cryptography_Cng phKey, 
					byte[] pbData, 
					int cbData, 
					int dwFlags)
		{
			// Setup
			bool addRefed = false;
			ushort* unsafe_pszBlobType = default(ushort*);
			global::System.IntPtr unsafe_phKey;
			byte* unsafe_pbData;
			global::_.Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng unsafe___value;
			// Marshalling
			hProvider.DangerousAddRef(ref addRefed);
			fixed (char* pinned_pszBlobType = pszBlobType)
			{
				unsafe_pszBlobType = (ushort*)pinned_pszBlobType;
				phKey = new global::Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle__System_Security_Cryptography_Cng();
				unsafe_phKey = phKey.DangerousGetHandle();
				fixed (byte* pinned_pbData = ((pbData != null 
							&& pbData.Length == 0) ? new byte[1] : pbData))
				{
					unsafe_pbData = (byte*)pinned_pbData;
					// Call to native method
					unsafe___value = global::__Interop.ncrypt_dll_PInvokes.NCryptImportKey(
										hProvider.DangerousGetHandle(), 
										hImportKey, 
										unsafe_pszBlobType, 
										pParameterList, 
										&(unsafe_phKey), 
										unsafe_pbData, 
										cbData, 
										dwFlags
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				}
				global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
									phKey, 
									unsafe_phKey
								);
			}
			if (addRefed)
				hProvider.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, NCryptGetProperty, [fwd] [return] [EETypeRva:0x00042D30] __Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng__Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng, [fwd] [in] [EETypeRva:0x00043474] Microsoft_Win32_SafeHandles_SafeNCryptHandle__System_Security_Cryptography_Cng____w64 int, [fwd] [in] [EETypeRva:0x00041B14] string__wchar_t *, [fwd] [out] [EETypeRva:0x00041980] void___ptrvoid *, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00042D30] System_Security_Cryptography_CngPropertyOptions__System_Security_Cryptography_Cng__CngPropertyOptions__System_Security_Cryptography_Cng, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Cng, Version=4.3.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+NCrypt", "NCryptGetProperty")]
		public static global::_.Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng NCryptGetProperty(
					global::Microsoft.Win32.SafeHandles.SafeNCryptHandle__System_Security_Cryptography_Cng hObject, 
					string pszProperty, 
					void* pbOutput, 
					int cbOutput, 
					out int pcbResult, 
					global::System_Security_Cryptography.CngPropertyOptions__System_Security_Cryptography_Cng dwFlags)
		{
			// Setup
			bool addRefed = false;
			ushort* unsafe_pszProperty = default(ushort*);
			global::_.Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng unsafe___value;
			// Marshalling
			hObject.DangerousAddRef(ref addRefed);
			fixed (char* pinned_pszProperty = pszProperty)
			{
				unsafe_pszProperty = (ushort*)pinned_pszProperty;
				fixed (int* pinned_pcbResult = &(pcbResult))
				{
					// Call to native method
					unsafe___value = global::__Interop.ncrypt_dll_PInvokes.NCryptGetProperty(
										hObject.DangerousGetHandle(), 
										unsafe_pszProperty, 
										((void*)pbOutput), 
										cbOutput, 
										pinned_pcbResult, 
										dwFlags
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				}
			}
			if (addRefed)
				hObject.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, NCryptSetProperty, [fwd] [return] [EETypeRva:0x00042D30] __Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng__Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng, [fwd] [in] [EETypeRva:0x00043474] Microsoft_Win32_SafeHandles_SafeNCryptHandle__System_Security_Cryptography_Cng____w64 int, [fwd] [in] [EETypeRva:0x00041B14] string__wchar_t *, [fwd] [in] [EETypeRva:0x00041980] void___ptrvoid *, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00042D30] System_Security_Cryptography_CngPropertyOptions__System_Security_Cryptography_Cng__CngPropertyOptions__System_Security_Cryptography_Cng, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Cng, Version=4.3.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+NCrypt", "NCryptSetProperty")]
		public static global::_.Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng NCryptSetProperty(
					global::Microsoft.Win32.SafeHandles.SafeNCryptHandle__System_Security_Cryptography_Cng hObject, 
					string pszProperty, 
					void* pbInput, 
					int cbInput, 
					global::System_Security_Cryptography.CngPropertyOptions__System_Security_Cryptography_Cng dwFlags)
		{
			// Setup
			bool addRefed = false;
			ushort* unsafe_pszProperty = default(ushort*);
			global::_.Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng unsafe___value;
			// Marshalling
			hObject.DangerousAddRef(ref addRefed);
			fixed (char* pinned_pszProperty = pszProperty)
			{
				unsafe_pszProperty = (ushort*)pinned_pszProperty;
				// Call to native method
				unsafe___value = global::__Interop.ncrypt_dll_PInvokes.NCryptSetProperty(
									hObject.DangerousGetHandle(), 
									unsafe_pszProperty, 
									((void*)pbInput), 
									cbInput, 
									dwFlags
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			}
			if (addRefed)
				hObject.DangerousRelease();
			// Return
			return unsafe___value;
		}
	}

	/// <summary>
	/// P/Invoke class for module 'iphlpapi.dll'
	/// </summary>
	public unsafe static partial class iphlpapi_dll
	{
		// Signature, GetNetworkParams, [fwd] [return] [EETypeRva:0x00041980] uint__unsigned int, [fwd] [in] [EETypeRva:0x00043474] Microsoft_Win32_SafeHandles_SafeLocalAllocHandle__System_Net_Primitives____w64 int, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x00041980] uint__unsigned int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Net.Primitives, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+IpHlpApi", "GetNetworkParams")]
		public static uint GetNetworkParams(
					global::Microsoft.Win32.SafeHandles.SafeLocalAllocHandle__System_Net_Primitives pFixedInfo, 
					ref uint pOutBufLen)
		{
			// Setup
			bool addRefed = false;
			uint unsafe___value;
			// Marshalling
			pFixedInfo.DangerousAddRef(ref addRefed);
			fixed (uint* pinned_pOutBufLen = &(pOutBufLen))
			{
				// Call to native method
				unsafe___value = global::__Interop.iphlpapi_dll_PInvokes.GetNetworkParams(
									pFixedInfo.DangerousGetHandle(), 
									pinned_pOutBufLen
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			}
			if (addRefed)
				pFixedInfo.DangerousRelease();
			// Return
			return unsafe___value;
		}
	}

	/// <summary>
	/// P/Invoke class for module 'BCrypt.dll'
	/// </summary>
	public unsafe static partial class BCrypt_dll
	{
		// Signature, BCryptGenRandom, [fwd] [return] [EETypeRva:0x00042D30] __Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms__Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x00041980] byte__unsigned char, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Algorithms, Version=4.3.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+BCrypt", "BCryptGenRandom")]
		public static global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms BCryptGenRandom(
					global::System.IntPtr hAlgorithm, 
					ref byte pbBuffer, 
					int cbBuffer, 
					int dwFlags)
		{
			// Setup
			global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms unsafe___value;
			// Marshalling
			fixed (byte* pinned_pbBuffer = &(pbBuffer))
			{
				// Call to native method
				unsafe___value = global::__Interop.BCrypt_dll_PInvokes.BCryptGenRandom(
									hAlgorithm, 
									pinned_pbBuffer, 
									cbBuffer, 
									dwFlags
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			}
			// Return
			return unsafe___value;
		}

		// Signature, BCryptExportKey, [fwd] [return] [EETypeRva:0x00042D30] __Interop_BCrypt_NTSTATUS__System_Security_Cryptography_X509Certificates__Interop_BCrypt_NTSTATUS__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00043474] Microsoft_Win32_SafeHandles_SafeBCryptKeyHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00041B14] string__wchar_t *, [fwd] [out] [EETypeRva:0x00042A10] rg_byte__unsigned char *, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+BCrypt", "BCryptExportKey")]
		public static global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_X509Certificates BCryptExportKey(
					global::Microsoft.Win32.SafeHandles.SafeBCryptKeyHandle__System_Security_Cryptography_X509Certificates hKey, 
					global::System.IntPtr hExportKey, 
					string pszBlobType, 
					byte[] pbOutput, 
					int cbOutput, 
					out int pcbResult, 
					int dwFlags)
		{
			// Setup
			bool addRefed = false;
			ushort* unsafe_pszBlobType = default(ushort*);
			byte* unsafe_pbOutput;
			global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_X509Certificates unsafe___value;
			// Marshalling
			hKey.DangerousAddRef(ref addRefed);
			fixed (char* pinned_pszBlobType = pszBlobType)
			{
				unsafe_pszBlobType = (ushort*)pinned_pszBlobType;
				fixed (byte* pinned_pbOutput = ((pbOutput != null 
							&& pbOutput.Length == 0) ? new byte[1] : pbOutput))
				{
					unsafe_pbOutput = (byte*)pinned_pbOutput;
					fixed (int* pinned_pcbResult = &(pcbResult))
					{
						// Call to native method
						unsafe___value = global::__Interop.BCrypt_dll_PInvokes.BCryptExportKey(
											hKey.DangerousGetHandle(), 
											hExportKey, 
											unsafe_pszBlobType, 
											unsafe_pbOutput, 
											cbOutput, 
											pinned_pcbResult, 
											dwFlags
										);
						global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
					}
				}
			}
			if (addRefed)
				hKey.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, BCryptGetProperty, [fwd] [return] [EETypeRva:0x00042D30] __Interop_BCrypt_NTSTATUS__System_Security_Cryptography_X509Certificates__Interop_BCrypt_NTSTATUS__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00043474] Microsoft_Win32_SafeHandles_SafeBCryptHandle__System_Security_Cryptography_X509Certificates____w64 int, [fwd] [in] [EETypeRva:0x00041B14] string__wchar_t *, [fwd] [in] [EETypeRva:0x00041980] void___ptrvoid *, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+BCrypt", "BCryptGetProperty")]
		public static global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_X509Certificates BCryptGetProperty(
					global::Microsoft.Win32.SafeHandles.SafeBCryptHandle__System_Security_Cryptography_X509Certificates hObject, 
					string pszProperty, 
					void* pbOutput, 
					int cbOutput, 
					out int pcbResult, 
					int dwFlags)
		{
			// Setup
			bool addRefed = false;
			ushort* unsafe_pszProperty = default(ushort*);
			global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_X509Certificates unsafe___value;
			// Marshalling
			hObject.DangerousAddRef(ref addRefed);
			fixed (char* pinned_pszProperty = pszProperty)
			{
				unsafe_pszProperty = (ushort*)pinned_pszProperty;
				fixed (int* pinned_pcbResult = &(pcbResult))
				{
					// Call to native method
					unsafe___value = global::__Interop.BCrypt_dll_PInvokes.BCryptGetProperty(
										hObject.DangerousGetHandle(), 
										unsafe_pszProperty, 
										((void*)pbOutput), 
										cbOutput, 
										pinned_pcbResult, 
										dwFlags
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				}
			}
			if (addRefed)
				hObject.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, BCryptDestroyKey, [fwd] [return] [EETypeRva:0x00042D30] __Interop_BCrypt_NTSTATUS__System_Security_Cryptography_X509Certificates__Interop_BCrypt_NTSTATUS__System_Security_Cryptography_X509Certificates, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.X509Certificates, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
			"", "Interop+BCrypt", "BCryptDestroyKey")]
		public static global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_X509Certificates BCryptDestroyKey(global::System.IntPtr hKey)
		{
			// Setup
			global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_X509Certificates unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop.BCrypt_dll_PInvokes.BCryptDestroyKey(hKey);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, BCryptCreateHash, [fwd] [return] [EETypeRva:0x00042D30] __Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms__Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms, [fwd] [in] [EETypeRva:0x00043474] Microsoft_Win32_SafeHandles_SafeBCryptAlgorithmHandle__System_Security_Cryptography_Algorithms____w64 int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x00043474] Microsoft_Win32_SafeHandles_SafeBCryptHashHandle__System_Security_Cryptography_Algorithms____w64 int, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [out] [EETypeRva:0x00042A10] rg_byte__unsigned char *, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00042D30] __Interop_BCrypt_BCryptCreateHashFlags__System_Security_Cryptography_Algorithms__Interop_BCrypt_BCryptCreateHashFlags__System_Security_Cryptography_Algorithms, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Algorithms, Version=4.3.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+BCrypt", "BCryptCreateHash")]
		public static global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms BCryptCreateHash(
					global::Microsoft.Win32.SafeHandles.SafeBCryptAlgorithmHandle__System_Security_Cryptography_Algorithms hAlgorithm, 
					out global::Microsoft.Win32.SafeHandles.SafeBCryptHashHandle__System_Security_Cryptography_Algorithms phHash, 
					global::System.IntPtr pbHashObject, 
					int cbHashObject, 
					byte[] pbSecret, 
					int cbSecret, 
					global::_.Interop_BCrypt_BCryptCreateHashFlags__System_Security_Cryptography_Algorithms dwFlags)
		{
			// Setup
			bool addRefed = false;
			global::System.IntPtr unsafe_phHash;
			byte* unsafe_pbSecret;
			global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms unsafe___value;
			// Marshalling
			hAlgorithm.DangerousAddRef(ref addRefed);
			phHash = new global::Microsoft.Win32.SafeHandles.SafeBCryptHashHandle__System_Security_Cryptography_Algorithms();
			unsafe_phHash = phHash.DangerousGetHandle();
			fixed (byte* pinned_pbSecret = ((pbSecret != null 
						&& pbSecret.Length == 0) ? new byte[1] : pbSecret))
			{
				unsafe_pbSecret = (byte*)pinned_pbSecret;
				// Call to native method
				unsafe___value = global::__Interop.BCrypt_dll_PInvokes.BCryptCreateHash(
									hAlgorithm.DangerousGetHandle(), 
									&(unsafe_phHash), 
									pbHashObject, 
									cbHashObject, 
									unsafe_pbSecret, 
									cbSecret, 
									dwFlags
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			}
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								phHash, 
								unsafe_phHash
							);
			if (addRefed)
				hAlgorithm.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, BCryptGetProperty__0, [fwd] [return] [EETypeRva:0x00042D30] __Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms__Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms, [fwd] [in] [EETypeRva:0x00043474] Microsoft_Win32_SafeHandles_SafeBCryptHandle__System_Security_Cryptography_Algorithms____w64 int, [fwd] [in] [EETypeRva:0x00041B14] string__wchar_t *, [fwd] [in] [EETypeRva:0x00041980] void___ptrvoid *, [fwd] [in] [EETypeRva:0x00041980] int__int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x00041980] int__int, [fwd] [in] [EETypeRva:0x00041980] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Algorithms, Version=4.3.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+BCrypt", "BCryptGetProperty")]
		public static global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms BCryptGetProperty__0(
					global::Microsoft.Win32.SafeHandles.SafeBCryptHandle__System_Security_Cryptography_Algorithms hObject, 
					string pszProperty, 
					void* pbOutput, 
					int cbOutput, 
					out int pcbResult, 
					int dwFlags)
		{
			// Setup
			bool addRefed = false;
			ushort* unsafe_pszProperty = default(ushort*);
			global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms unsafe___value;
			// Marshalling
			hObject.DangerousAddRef(ref addRefed);
			fixed (char* pinned_pszProperty = pszProperty)
			{
				unsafe_pszProperty = (ushort*)pinned_pszProperty;
				fixed (int* pinned_pcbResult = &(pcbResult))
				{
					// Call to native method
					unsafe___value = global::__Interop.BCrypt_dll_PInvokes.BCryptGetProperty__0(
										hObject.DangerousGetHandle(), 
										unsafe_pszProperty, 
										((void*)pbOutput), 
										cbOutput, 
										pinned_pcbResult, 
										dwFlags
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				}
			}
			if (addRefed)
				hObject.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, BCryptOpenAlgorithmProvider, [fwd] [return] [EETypeRva:0x00042D30] __Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms__Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x00043474] Microsoft_Win32_SafeHandles_SafeBCryptAlgorithmHandle__System_Security_Cryptography_Algorithms____w64 int, [fwd] [in] [EETypeRva:0x00041B14] string__wchar_t *, [fwd] [in] [EETypeRva:0x00041B14] string__wchar_t *, [fwd] [in] [EETypeRva:0x00042D30] __Interop_BCrypt_BCryptOpenAlgorithmProviderFlags__System_Security_Cryptography_Algorithms__Interop_BCrypt_BCryptOpenAlgorithmProviderFlags__System_Security_Cryptography_Algorithms, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Algorithms, Version=4.3.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+BCrypt", "BCryptOpenAlgorithmProvider")]
		public static global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms BCryptOpenAlgorithmProvider(
					out global::Microsoft.Win32.SafeHandles.SafeBCryptAlgorithmHandle__System_Security_Cryptography_Algorithms phAlgorithm, 
					string pszAlgId, 
					string pszImplementation, 
					global::_.Interop_BCrypt_BCryptOpenAlgorithmProviderFlags__System_Security_Cryptography_Algorithms dwFlags)
		{
			// Setup
			global::System.IntPtr unsafe_phAlgorithm;
			ushort* unsafe_pszAlgId = default(ushort*);
			ushort* unsafe_pszImplementation = default(ushort*);
			global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms unsafe___value;
			// Marshalling
			phAlgorithm = new global::Microsoft.Win32.SafeHandles.SafeBCryptAlgorithmHandle__System_Security_Cryptography_Algorithms();
			unsafe_phAlgorithm = phAlgorithm.DangerousGetHandle();
			fixed (char* pinned_pszAlgId = pszAlgId)
			{
				unsafe_pszAlgId = (ushort*)pinned_pszAlgId;
				fixed (char* pinned_pszImplementation = pszImplementation)
				{
					unsafe_pszImplementation = (ushort*)pinned_pszImplementation;
					// Call to native method
					unsafe___value = global::__Interop.BCrypt_dll_PInvokes.BCryptOpenAlgorithmProvider(
										&(unsafe_phAlgorithm), 
										unsafe_pszAlgId, 
										unsafe_pszImplementation, 
										dwFlags
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				}
			}
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								phAlgorithm, 
								unsafe_phAlgorithm
							);
			// Return
			return unsafe___value;
		}

		// Signature, BCryptCloseAlgorithmProvider, [fwd] [return] [EETypeRva:0x00042D30] __Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms__Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00041980] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Algorithms, Version=4.3.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+BCrypt", "BCryptCloseAlgorithmProvider")]
		public static global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms BCryptCloseAlgorithmProvider(
					global::System.IntPtr hAlgorithm, 
					int dwFlags)
		{
			// Setup
			global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop.BCrypt_dll_PInvokes.BCryptCloseAlgorithmProvider(
								hAlgorithm, 
								dwFlags
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, BCryptDestroyHash, [fwd] [return] [EETypeRva:0x00042D30] __Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms__Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms, [fwd] [in] [EETypeRva:0x00041980] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Security.Cryptography.Algorithms, Version=4.3.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+BCrypt", "BCryptDestroyHash")]
		public static global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms BCryptDestroyHash(global::System.IntPtr hHash)
		{
			// Setup
			global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop.BCrypt_dll_PInvokes.BCryptDestroyHash(hHash);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}
	}

	/// <summary>
	/// P/Invoke class for module 'api-ms-win-core-winrt-robuffer-l1-1-0.dll'
	/// </summary>
	public unsafe static partial class api_ms_win_core_winrt_robuffer_l1_1_0_dll
	{
		// Signature, RoGetBufferMarshaler, [fwd] [return] [EETypeRva:0x00041980] int__int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x00043630] System_Runtime_InteropServices_IMarshal__System_Runtime_WindowsRuntime__System_Runtime_InteropServices__IMarshal__System_Runtime_WindowsRuntime *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Runtime.WindowsRuntime, Version=4.0.14.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", "Interop+mincore", "RoGetBufferMarshaler")]
		public static int RoGetBufferMarshaler(out global::System_Runtime_InteropServices.IMarshal__System_Runtime_WindowsRuntime bufferMarshalerPtr)
		{
			// Setup
			void* unsafe_bufferMarshalerPtr = default(void*);
			int unsafe___value;
			try
			{
				// Marshalling
				unsafe_bufferMarshalerPtr = null;
				// Call to native method
				unsafe___value = global::__Interop.api_ms_win_core_winrt_robuffer_l1_1_0_dll_PInvokes.RoGetBufferMarshaler(&(unsafe_bufferMarshalerPtr));
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				bufferMarshalerPtr = (global::System_Runtime_InteropServices.IMarshal__System_Runtime_WindowsRuntime)global::System.Runtime.InteropServices.McgMarshal.ComInterfaceToObject(
									((global::System.IntPtr)unsafe_bufferMarshalerPtr), 
									global::System.Runtime.InteropServices.TypeOfHelper.RuntimeTypeHandleOf("System.Runtime.InteropServices.IMarshal,System.Runtime.WindowsRuntime, Version=4.0.14.0, Culture=neutral, Public" +
											"KeyToken=b77a5c561934e089")
								);
				// Return
				return unsafe___value;
			}
			finally
			{
				// Cleanup
				global::System.Runtime.InteropServices.McgMarshal.ComSafeRelease(new global::System.IntPtr(((void*)unsafe_bufferMarshalerPtr)));
			}
		}
	}

	public unsafe static partial class _MRT__PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("[MRT]", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
		public extern static uint RhpGetFuncEvalParameterBufferSize();

		[global::System.Runtime.InteropServices.DllImport("[MRT]", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
		public extern static uint RhpGetFuncEvalMode();

		[global::System.Runtime.InteropServices.DllImport("[MRT]", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
		public extern static uint RhpRecordDebuggeeInitiatedHandle(void* objectHandle);

		[global::System.Runtime.InteropServices.DllImport("[MRT]", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
		public extern static void RhpVerifyDebuggerCleanup();

		[global::System.Runtime.InteropServices.DllImport("[MRT]", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
		public extern static global::System.IntPtr RhpGetCurrentThread();

		[global::System.Runtime.InteropServices.DllImport("[MRT]", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static void RhWaitForPendingFinalizers(int allowReentrantWait);

		[global::System.Runtime.InteropServices.DllImport("[MRT]", EntryPoint="RhYield", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
		public extern static int _RhYield();

		[global::System.Runtime.InteropServices.DllImport("[MRT]", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
		public extern static void RhFlushProcessWriteBuffers();

		[global::System.Runtime.InteropServices.DllImport("[MRT]", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int RhCompatibleReentrantWaitAny(
					int alertable, 
					int timeout, 
					int count, 
					global::System.IntPtr* handles);

		[global::System.Runtime.InteropServices.DllImport("[MRT]", EntryPoint="RhCallDescrWorker", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static void RhCallDescrWorkerNative(global::System.IntPtr callDescr);

		[global::System.Runtime.InteropServices.DllImport("[MRT]", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static void _ecvt_s(
					byte* buffer, 
					int sizeInBytes, 
					double value, 
					int count, 
					int* dec, 
					int* sign);

		[global::System.Runtime.InteropServices.DllImport("[MRT]", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static void memmove(
					byte* dmem, 
					byte* smem, 
					uint size);

		[global::System.Runtime.InteropServices.DllImport("[MRT]", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static void memset(
					byte* mem, 
					int value, 
					uint size);
	}

	public unsafe static partial class __PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("*", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static void CallingConventionConverter_GetStubs(
					global::System.IntPtr* returnVoidStub, 
					global::System.IntPtr* returnIntegerStub, 
					global::System.IntPtr* commonStub, 
					global::System.IntPtr* returnFloatingPointReturn4Thunk, 
					global::System.IntPtr* returnFloatingPointReturn8Thunk);
	}

	public unsafe static partial class api_ms_win_core_winrt_string_l1_1_0_dll_PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-winrt-string-l1-1-0.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int WindowsCreateStringReference(
					ushort* sourceString, 
					uint length, 
					global::System_Runtime_InteropServices.HSTRING_HEADER__System_Private_Interop* phstringHeader, 
					void* hstring);
	}

	public unsafe static partial class api_ms_win_core_errorhandling_l1_1_0_dll_PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-errorhandling-l1-1-0.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int GetLastError();

		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-errorhandling-l1-1-0.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static void SetLastError(uint dwErrCode);
	}

	public unsafe static partial class api_ms_win_core_winrt_l1_1_0_dll_PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-winrt-l1-1-0.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int RoInitialize(uint initType);
	}

	public unsafe static partial class api_ms_win_core_localization_l1_2_0_dll_PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-localization-l1-2-0.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int IsValidLocaleName(ushort* lpLocaleName);

		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-localization-l1-2-0.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int ResolveLocaleName(
					ushort* lpNameToResolve, 
					ushort* lpLocaleName, 
					int cchLocaleName);
	}

	public unsafe static partial class crypt32_dll_PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr CertDuplicateCertificateContext(global::System.IntPtr pCertContext);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CertGetCertificateContextProperty(
					global::System.IntPtr pCertContext, 
					global::Internal_Cryptography_Pal_Native.CertContextPropId__System_Security_Cryptography_X509Certificates dwPropId, 
					global::Internal_Cryptography_Pal_Native.CRYPTOAPI_BLOB__System_Security_Cryptography_X509Certificates* pvData, 
					int* pcbData);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CryptQueryObject(
					global::Internal_Cryptography_Pal_Native.CertQueryObjectType__System_Security_Cryptography_X509Certificates dwObjectType, 
					void* pvObject, 
					global::Internal_Cryptography_Pal_Native.ExpectedContentTypeFlags__System_Security_Cryptography_X509Certificates dwExpectedContentTypeFlags, 
					global::Internal_Cryptography_Pal_Native.ExpectedFormatTypeFlags__System_Security_Cryptography_X509Certificates dwExpectedFormatTypeFlags, 
					int dwFlags, 
					global::Internal_Cryptography_Pal_Native.CertEncodingType__System_Security_Cryptography_X509Certificates* pdwMsgAndCertEncodingType, 
					global::Internal_Cryptography_Pal_Native.ContentType__System_Security_Cryptography_X509Certificates* pdwContentType, 
					global::Internal_Cryptography_Pal_Native.FormatType__System_Security_Cryptography_X509Certificates* pdwFormatType, 
					global::System.IntPtr* phCertStore, 
					global::System.IntPtr* phMsg, 
					global::System.IntPtr* ppvContext);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", EntryPoint="CertDuplicateCertificateContext", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr CertDuplicateCertificateContextWithKeyContainerDeletion(global::System.IntPtr pCertContext);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CertFreeCertificateContext(global::System.IntPtr pCertContext);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CryptMsgGetParam(
					global::System.IntPtr hCryptMsg, 
					global::Internal_Cryptography_Pal_Native.CryptMessageParameterType__System_Security_Cryptography_X509Certificates dwParamType, 
					int dwIndex, 
					int* pvData, 
					int* pcbData);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", EntryPoint="CryptMsgGetParam", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CryptMsgGetParam__0(
					global::System.IntPtr hCryptMsg, 
					global::Internal_Cryptography_Pal_Native.CryptMessageParameterType__System_Security_Cryptography_X509Certificates dwParamType, 
					int dwIndex, 
					byte* pvData, 
					int* pcbData);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr PFXImportCertStore(
					global::Internal_Cryptography_Pal_Native.CRYPTOAPI_BLOB__System_Security_Cryptography_X509Certificates* pPFX, 
					global::System.IntPtr password, 
					global::Internal_Cryptography_Pal_Native.PfxCertStoreFlags__System_Security_Cryptography_X509Certificates dwFlags);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr CryptFindOIDInfo(
					global::_.Interop_Crypt32_CryptOidInfoKeyType__System_Security_Cryptography_Encoding dwKeyType, 
					global::System.IntPtr pvKey, 
					global::System_Security_Cryptography.OidGroup__System_Security_Cryptography_Encoding group);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", EntryPoint="CertGetCertificateContextProperty", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CertGetCertificateContextProperty__0(
					global::System.IntPtr pCertContext, 
					global::Internal_Cryptography_Pal_Native.CertContextPropId__System_Security_Cryptography_X509Certificates dwPropId, 
					byte* pvData, 
					int* pcbData);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CertCloseStore(
					global::System.IntPtr hCertStore, 
					int dwFlags);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CryptMsgClose(global::System.IntPtr hCryptMsg);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr CertFindCertificateInStore(
					global::System.IntPtr hCertStore, 
					global::Internal_Cryptography_Pal_Native.CertEncodingType__System_Security_Cryptography_X509Certificates dwCertEncodingType, 
					global::Internal_Cryptography_Pal_Native.CertFindFlags__System_Security_Cryptography_X509Certificates dwFindFlags, 
					global::Internal_Cryptography_Pal_Native.CertFindType__System_Security_Cryptography_X509Certificates dwFindType, 
					void* pvFindPara, 
					global::Internal_Cryptography_Pal_Native.CERT_CONTEXT__System_Security_Cryptography_X509Certificates* pPrevCertContext);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr CertEnumCertificatesInStore(
					global::System.IntPtr hCertStore, 
					global::Internal_Cryptography_Pal_Native.CERT_CONTEXT__System_Security_Cryptography_X509Certificates* pPrevCertContext);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", EntryPoint="CertGetNameStringW", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CertGetNameString(
					global::System.IntPtr pCertContext, 
					global::Internal_Cryptography_Pal_Native.CertNameType__System_Security_Cryptography_X509Certificates dwType, 
					global::Internal_Cryptography_Pal_Native.CertNameFlags__System_Security_Cryptography_X509Certificates dwFlags, 
					global::Internal_Cryptography_Pal_Native.CertNameStringType__System_Security_Cryptography_X509Certificates* pvTypePara, 
					ushort* pszNameString, 
					int cchNameString);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", EntryPoint="CertGetNameStringW", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CertGetNameString__0(
					global::System.IntPtr pCertContext, 
					global::Internal_Cryptography_Pal_Native.CertNameType__System_Security_Cryptography_X509Certificates dwType, 
					global::Internal_Cryptography_Pal_Native.CertNameFlags__System_Security_Cryptography_X509Certificates dwFlags, 
					global::Internal_Cryptography_Pal_Native.CertNameStrTypeAndFlags__System_Security_Cryptography_X509Certificates* pvPara, 
					ushort* pszNameString, 
					int cchNameString);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", EntryPoint="CryptFindOIDInfo", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr CryptFindOIDInfo__0(
					global::_.Interop_Crypt32_CryptOidInfoKeyType__System_Security_Cryptography_X509Certificates dwKeyType, 
					global::System.IntPtr pvKey, 
					global::System_Security_Cryptography.OidGroup__System_Security_Cryptography_Encoding group);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CertGetCertificateChain(
					global::System.IntPtr hChainEngine, 
					global::System.IntPtr pCertContext, 
					global::Internal_Cryptography_Pal_Native.FILETIME__System_Security_Cryptography_X509Certificates* pTime, 
					global::System.IntPtr hStore, 
					global::Internal_Cryptography_Pal_Native.CERT_CHAIN_PARA__System_Security_Cryptography_X509Certificates* pChainPara, 
					global::Internal_Cryptography_Pal_Native.CertChainFlags__System_Security_Cryptography_X509Certificates dwFlags, 
					global::System.IntPtr pvReserved, 
					global::System.IntPtr* ppChainContext);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CertVerifyCertificateChainPolicy(
					global::System.IntPtr pszPolicyOID, 
					global::System.IntPtr pChainContext, 
					global::Internal_Cryptography_Pal_Native.CERT_CHAIN_POLICY_PARA__System_Security_Cryptography_X509Certificates* pPolicyPara, 
					global::Internal_Cryptography_Pal_Native.CERT_CHAIN_POLICY_STATUS__System_Security_Cryptography_X509Certificates* pPolicyStatus);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", EntryPoint="CertNameToStrW", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CertNameToStr(
					global::Internal_Cryptography_Pal_Native.CertEncodingType__System_Security_Cryptography_X509Certificates dwCertEncodingType, 
					global::Internal_Cryptography_Pal_Native.CRYPTOAPI_BLOB__System_Security_Cryptography_X509Certificates* pName, 
					global::Internal_Cryptography_Pal_Native.CertNameStrTypeAndFlags__System_Security_Cryptography_X509Certificates dwStrType, 
					ushort* psz, 
					int csz);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CryptFormatObject(
					int dwCertEncodingType, 
					int dwFormatType, 
					int dwFormatStrType, 
					global::System.IntPtr pFormatStruct, 
					byte* lpszStructType, 
					byte* pbEncoded, 
					int cbEncoded, 
					ushort* pbFormat, 
					int* pcbFormat);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CertAddCertificateLinkToStore(
					global::System.IntPtr hCertStore, 
					global::System.IntPtr pCertContext, 
					global::Internal_Cryptography_Pal_Native.CertStoreAddDisposition__System_Security_Cryptography_X509Certificates dwAddDisposition, 
					global::System.IntPtr ppStoreContext);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", EntryPoint="CryptFormatObject", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CryptFormatObject__0(
					global::Internal_Cryptography_Pal_Native.CertEncodingType__System_Security_Cryptography_X509Certificates dwCertEncodingType, 
					global::Internal_Cryptography_Pal_Native.FormatObjectType__System_Security_Cryptography_X509Certificates dwFormatType, 
					global::Internal_Cryptography_Pal_Native.FormatObjectStringType__System_Security_Cryptography_X509Certificates dwFormatStrType, 
					global::System.IntPtr pFormatStruct, 
					global::System.IntPtr lpszStructType, 
					byte* pbEncoded, 
					int cbEncoded, 
					ushort* pbFormat, 
					int* pcbFormat);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr CertOpenStore(
					global::System.IntPtr lpszStoreProvider, 
					global::Internal_Cryptography_Pal_Native.CertEncodingType__System_Security_Cryptography_X509Certificates dwMsgAndCertEncodingType, 
					global::System.IntPtr hCryptProv, 
					global::Internal_Cryptography_Pal_Native.CertStoreFlags__System_Security_Cryptography_X509Certificates dwFlags, 
					ushort* pvPara);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CryptImportPublicKeyInfoEx2(
					global::Internal_Cryptography_Pal_Native.CertEncodingType__System_Security_Cryptography_X509Certificates dwCertEncodingType, 
					global::Internal_Cryptography_Pal_Native.CERT_PUBLIC_KEY_INFO__System_Security_Cryptography_X509Certificates* pInfo, 
					int dwFlags, 
					void* pvAuxInfo, 
					global::System.IntPtr* phKey);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CryptDecodeObject(
					global::Internal_Cryptography_Pal_Native.CertEncodingType__System_Security_Cryptography_X509Certificates dwCertEncodingType, 
					global::System.IntPtr lpszStructType, 
					byte* pbEncoded, 
					int cbEncoded, 
					global::Internal_Cryptography_Pal_Native.CryptDecodeObjectFlags__System_Security_Cryptography_X509Certificates dwFlags, 
					byte* pvStructInfo, 
					int* pcbStructInfo);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static void CertFreeCertificateChain(global::System.IntPtr pChainContext);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CertControlStore(
					global::System.IntPtr hCertStore, 
					global::Internal_Cryptography_Pal_Native.CertControlStoreFlags__System_Security_Cryptography_X509Certificates dwFlags, 
					global::Internal_Cryptography_Pal_Native.CertControlStoreType__System_Security_Cryptography_X509Certificates dwControlType, 
					global::System.IntPtr pvCtrlPara);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", EntryPoint="CryptDecodeObject", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CryptDecodeObjectPointer(
					global::Internal_Cryptography_Pal_Native.CertEncodingType__System_Security_Cryptography_X509Certificates dwCertEncodingType, 
					global::System.IntPtr lpszStructType, 
					byte* pbEncoded, 
					int cbEncoded, 
					global::Internal_Cryptography_Pal_Native.CryptDecodeObjectFlags__System_Security_Cryptography_X509Certificates dwFlags, 
					void* pvStructInfo, 
					int* pcbStructInfo);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::Internal_Cryptography_Pal_Native.CERT_EXTENSION__System_Security_Cryptography_X509Certificates* CertFindExtension(
					byte* pszObjId, 
					int cExtensions, 
					global::Internal_Cryptography_Pal_Native.CERT_EXTENSION__System_Security_Cryptography_X509Certificates* rgExtensions);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CertGetValidUsages(
					int cCerts, 
					global::System.IntPtr* rghCerts, 
					int* cNumOIDs, 
					void* rghOIDs, 
					int* pcbOIDs);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CertGetIntendedKeyUsage(
					global::Internal_Cryptography_Pal_Native.CertEncodingType__System_Security_Cryptography_X509Certificates dwCertEncodingType, 
					global::Internal_Cryptography_Pal_Native.CERT_INFO__System_Security_Cryptography_X509Certificates* pCertInfo, 
					global::System_Security_Cryptography_X509Certificates.X509KeyUsageFlags__System_Security_Cryptography_X509Certificates* pbKeyUsage, 
					int cbKeyUsage);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", EntryPoint="CryptFindOIDInfo", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr CryptFindOIDInfo__1(
					global::_.Interop_Crypt32_CryptOidInfoKeyType__System_Security_Cryptography_Cng dwKeyType, 
					global::System.IntPtr pvKey, 
					global::System_Security_Cryptography.OidGroup__System_Security_Cryptography_Encoding group);

		[global::System.Runtime.InteropServices.DllImport("crypt32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CertVerifyTimeValidity(
					global::Internal_Cryptography_Pal_Native.FILETIME__System_Security_Cryptography_X509Certificates* pTimeToVerify, 
					global::Internal_Cryptography_Pal_Native.CERT_INFO__System_Security_Cryptography_X509Certificates* pCertInfo);
	}

	public unsafe static partial class kernel32_dll_PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int GetCPInfoExW(
					uint CodePage, 
					uint dwFlags, 
					global::_.Interop_Kernel32_CPINFOEXW__System_Text_Encoding_CodePages* lpCPInfoEx);

		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", EntryPoint="FormatMessageW", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int FormatMessage(
					int dwFlags, 
					global::System.IntPtr lpSource, 
					uint dwMessageId, 
					int dwLanguageId, 
					ushort* lpBuffer, 
					int nSize, 
					global::System.IntPtr* arguments);

		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr LocalAlloc(
					int uFlags, 
					global::System.UIntPtr sizetdwBytes);

		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr LocalFree(global::System.IntPtr handle);

		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", EntryPoint="FormatMessageW", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int FormatMessage__0(
					int dwFlags, 
					global::System.IntPtr lpSource, 
					uint dwMessageId, 
					int dwLanguageId, 
					ushort* lpBuffer, 
					int nSize, 
					global::System.IntPtr* arguments);

		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", EntryPoint="FormatMessageW", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int FormatMessage__1(
					int dwFlags, 
					global::System.IntPtr lpSource, 
					uint dwMessageId, 
					int dwLanguageId, 
					ushort* lpBuffer, 
					int nSize, 
					global::System.IntPtr* arguments);

		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", EntryPoint="FormatMessageW", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int FormatMessage__2(
					int dwFlags, 
					global::System.IntPtr lpSource, 
					uint dwMessageId, 
					int dwLanguageId, 
					ushort* lpBuffer, 
					int nSize, 
					global::System.IntPtr* arguments);

		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", EntryPoint="FormatMessageW", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int FormatMessage__3(
					int dwFlags, 
					global::System.IntPtr lpSource, 
					uint dwMessageId, 
					int dwLanguageId, 
					ushort* lpBuffer, 
					int nSize, 
					global::System.IntPtr* arguments);
	}

	public unsafe static partial class api_ms_win_core_com_l1_1_0_dll_PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-com-l1-1-0.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CoCreateInstance(
					byte* rclsid, 
					global::System.IntPtr pUnkOuter, 
					int dwClsContext, 
					byte* riid, 
					global::System.IntPtr* ppv);
	}

	public unsafe static partial class advapi32_dll_PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("advapi32.dll", EntryPoint="CryptAcquireContextW", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CryptAcquireContext(
					global::System.IntPtr* psafeProvHandle, 
					ushort* pszContainer, 
					ushort* pszProvider, 
					int dwProvType, 
					global::Internal_Cryptography_Pal_Native.CryptAcquireContextFlags__System_Security_Cryptography_X509Certificates dwFlags);

		[global::System.Runtime.InteropServices.DllImport("advapi32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CryptGetKeyParam(
					global::System.IntPtr safeKeyHandle, 
					int dwParam, 
					byte* pbData, 
					int* pdwDataLen, 
					int dwFlags);

		[global::System.Runtime.InteropServices.DllImport("advapi32.dll", EntryPoint="CryptGetDefaultProviderW", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CryptGetDefaultProvider(
					int dwProvType, 
					global::System.IntPtr pdwReserved, 
					int dwFlags, 
					ushort* pszProvName, 
					int* IntPtrProvName);

		[global::System.Runtime.InteropServices.DllImport("advapi32.dll", EntryPoint="CryptAcquireContextW", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CryptAcquireContext__0(
					global::System.IntPtr* psafeProvHandle, 
					ushort* pszContainer, 
					ushort* pszProvider, 
					int dwProvType, 
					uint dwFlags);

		[global::System.Runtime.InteropServices.DllImport("advapi32.dll", EntryPoint="CryptGetUserKey", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int _CryptGetUserKey(
					global::System.IntPtr safeProvHandle, 
					int dwKeySpec, 
					global::System.IntPtr* safeKeyHandle);

		[global::System.Runtime.InteropServices.DllImport("advapi32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CryptGetProvParam(
					global::System.IntPtr safeProvHandle, 
					global::_.Interop_Advapi32_CryptProvParam__System_Security_Cryptography_Csp dwParam, 
					global::System.IntPtr pbData, 
					int* dwDataLen, 
					int dwFlags);

		[global::System.Runtime.InteropServices.DllImport("advapi32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CryptDestroyKey(global::System.IntPtr hKey);

		[global::System.Runtime.InteropServices.DllImport("advapi32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CryptReleaseContext(
					global::System.IntPtr safeProvHandle, 
					int dwFlags);

		[global::System.Runtime.InteropServices.DllImport("advapi32.dll", EntryPoint="CryptImportKey", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int _CryptImportKey(
					global::System.IntPtr hProv, 
					byte* pbData, 
					int dwDataLen, 
					global::System.IntPtr hPubKey, 
					int dwFlags, 
					global::System.IntPtr* phKey);

		[global::System.Runtime.InteropServices.DllImport("advapi32.dll", EntryPoint="CryptSetProvParam", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CryptSetProvParamIndirectPtr(
					global::System.IntPtr safeProvHandle, 
					global::_.Interop_Advapi32_CryptProvParam__System_Security_Cryptography_Csp dwParam, 
					global::System.IntPtr* pbData, 
					int dwFlags);

		[global::System.Runtime.InteropServices.DllImport("advapi32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CryptSetProvParam(
					global::System.IntPtr safeProvHandle, 
					global::_.Interop_Advapi32_CryptProvParam__System_Security_Cryptography_Csp dwParam, 
					global::System.IntPtr pbData, 
					int dwFlags);

		[global::System.Runtime.InteropServices.DllImport("advapi32.dll", EntryPoint="CryptGenKey", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int _CryptGenKey(
					global::System.IntPtr safeProvHandle, 
					int Algid, 
					int dwFlags, 
					global::System.IntPtr* safeKeyHandle);
	}

	public unsafe static partial class ws2_32_dll_PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int WSAGetOverlappedResult(
					global::System.IntPtr socketHandle, 
					global::System_Threading.NativeOverlapped__System_Private_CoreLib* overlapped, 
					uint* bytesTransferred, 
					int wait, 
					global::System_Net_Sockets.SocketFlags__System_Net_Sockets* socketFlags);

		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System_Net_Sockets.SocketError__System_Net_Primitives setsockopt(
					global::System.IntPtr socketHandle, 
					global::System_Net_Sockets.SocketOptionLevel__System_Net_Sockets optionLevel, 
					global::System_Net_Sockets.SocketOptionName__System_Net_Sockets optionName, 
					global::System.IntPtr* pointer, 
					int optionLength);

		[global::System.Runtime.InteropServices.DllImport("ws2_32.dll", EntryPoint="setsockopt", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System_Net_Sockets.SocketError__System_Net_Primitives setsockopt__0(
					global::System.IntPtr socketHandle, 
					global::System_Net_Sockets.SocketOptionLevel__System_Net_Sockets optionLevel, 
					global::System_Net_Sockets.SocketOptionName__System_Net_Sockets optionName, 
					byte* optionValue, 
					int optionLength);
	}

	public unsafe static partial class OleAut32_PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("OleAut32", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static void SysFreeString(global::System.IntPtr bstr);
	}

	public unsafe static partial class ncrypt_dll_PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("ncrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::_.Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng NCryptOpenKey(
					global::System.IntPtr hProvider, 
					global::System.IntPtr* phKey, 
					ushort* pszKeyName, 
					int dwLegacyKeySpec, 
					global::System_Security_Cryptography.CngKeyOpenOptions__System_Security_Cryptography_Cng dwFlags);

		[global::System.Runtime.InteropServices.DllImport("ncrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::_.Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng NCryptDeleteKey(
					global::System.IntPtr hKey, 
					int dwFlags);

		[global::System.Runtime.InteropServices.DllImport("ncrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::_.Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng NCryptOpenStorageProvider(
					global::System.IntPtr* phProvider, 
					ushort* pszProviderName, 
					int dwFlags);

		[global::System.Runtime.InteropServices.DllImport("ncrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::_.Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng NCryptFreeObject(global::System.IntPtr hObject);

		[global::System.Runtime.InteropServices.DllImport("ncrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::_.Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng NCryptImportKey(
					global::System.IntPtr hProvider, 
					global::System.IntPtr hImportKey, 
					ushort* pszBlobType, 
					global::System.IntPtr pParameterList, 
					global::System.IntPtr* phKey, 
					byte* pbData, 
					int cbData, 
					int dwFlags);

		[global::System.Runtime.InteropServices.DllImport("ncrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::_.Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng NCryptGetProperty(
					global::System.IntPtr hObject, 
					ushort* pszProperty, 
					void* pbOutput, 
					int cbOutput, 
					int* pcbResult, 
					global::System_Security_Cryptography.CngPropertyOptions__System_Security_Cryptography_Cng dwFlags);

		[global::System.Runtime.InteropServices.DllImport("ncrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::_.Interop_NCrypt_ErrorCode__System_Security_Cryptography_Cng NCryptSetProperty(
					global::System.IntPtr hObject, 
					ushort* pszProperty, 
					void* pbInput, 
					int cbInput, 
					global::System_Security_Cryptography.CngPropertyOptions__System_Security_Cryptography_Cng dwFlags);
	}

	public unsafe static partial class iphlpapi_dll_PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("iphlpapi.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static uint GetNetworkParams(
					global::System.IntPtr pFixedInfo, 
					uint* pOutBufLen);
	}

	public unsafe static partial class BCrypt_dll_PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("BCrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms BCryptGenRandom(
					global::System.IntPtr hAlgorithm, 
					byte* pbBuffer, 
					int cbBuffer, 
					int dwFlags);

		[global::System.Runtime.InteropServices.DllImport("BCrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_X509Certificates BCryptExportKey(
					global::System.IntPtr hKey, 
					global::System.IntPtr hExportKey, 
					ushort* pszBlobType, 
					byte* pbOutput, 
					int cbOutput, 
					int* pcbResult, 
					int dwFlags);

		[global::System.Runtime.InteropServices.DllImport("BCrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_X509Certificates BCryptGetProperty(
					global::System.IntPtr hObject, 
					ushort* pszProperty, 
					void* pbOutput, 
					int cbOutput, 
					int* pcbResult, 
					int dwFlags);

		[global::System.Runtime.InteropServices.DllImport("BCrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_X509Certificates BCryptDestroyKey(global::System.IntPtr hKey);

		[global::System.Runtime.InteropServices.DllImport("BCrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms BCryptCreateHash(
					global::System.IntPtr hAlgorithm, 
					global::System.IntPtr* phHash, 
					global::System.IntPtr pbHashObject, 
					int cbHashObject, 
					byte* pbSecret, 
					int cbSecret, 
					global::_.Interop_BCrypt_BCryptCreateHashFlags__System_Security_Cryptography_Algorithms dwFlags);

		[global::System.Runtime.InteropServices.DllImport("BCrypt.dll", EntryPoint="BCryptGetProperty", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms BCryptGetProperty__0(
					global::System.IntPtr hObject, 
					ushort* pszProperty, 
					void* pbOutput, 
					int cbOutput, 
					int* pcbResult, 
					int dwFlags);

		[global::System.Runtime.InteropServices.DllImport("BCrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms BCryptOpenAlgorithmProvider(
					global::System.IntPtr* phAlgorithm, 
					ushort* pszAlgId, 
					ushort* pszImplementation, 
					global::_.Interop_BCrypt_BCryptOpenAlgorithmProviderFlags__System_Security_Cryptography_Algorithms dwFlags);

		[global::System.Runtime.InteropServices.DllImport("BCrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms BCryptCloseAlgorithmProvider(
					global::System.IntPtr hAlgorithm, 
					int dwFlags);

		[global::System.Runtime.InteropServices.DllImport("BCrypt.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::_.Interop_BCrypt_NTSTATUS__System_Security_Cryptography_Algorithms BCryptDestroyHash(global::System.IntPtr hHash);
	}

	public unsafe static partial class api_ms_win_core_winrt_robuffer_l1_1_0_dll_PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-winrt-robuffer-l1-1-0.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.StdCall)]
		public extern static int RoGetBufferMarshaler(void** bufferMarshalerPtr);
	}
}

